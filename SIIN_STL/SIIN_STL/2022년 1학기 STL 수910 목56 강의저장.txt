

파일 이름 : 소스.cpp
파일크기:1720
2022-03-02 20:33:18 GMT+9



//-----------------------------------------------------------------------------
// 2022년 1학기 STL	3.2 수910	수910목56	 (1주 1일)
//
// - 강의소개
// - 교과서 - 사이트 : cppreference.com
// - 코딩스타일 : google coding convention
// - 프로젝트 환경 : Release/x64
//		메뉴 - 프로젝트  - 설정 - C++언어(초안기능)
//
// - Save 파일 만들기
//-----------------------------------------------------------------------------


#include <iostream>
#include <string_view>
#include <string_view>
#include <filesystem>
#include <chrono>
#include <fstream>
#include <vector>
#include <algorithm>

using namespace std;	// 이걸 안써야 하겠다.

void save(string_view);

int main()
{
	// string과 string_view 크기를 출력하라
	cout << "string의 크기 - " << sizeof(string) << "\n";
	cout << "string_view의 크기 - " << sizeof(string_view) << "\n";

	save("소스.cpp");
}

void save(string_view fname)
{
	// 읽을 파일을 연다.
	ifstream in{ fname.data() };

	// 쓸 파일도 연다.
	ofstream out{ "2022년 1학기 STL 수910 목56 강의저장.txt", ios::app };

	out << "\n\n";

	// 저장할 파일의 이름을 파일에 출력한다
	out << "파일 이름 : " << fname << "\n";

	// 저장할 파일의 크기를 출력한다(c++17)
	out << "파일크기:" << filesystem::file_size(fname) << "\n";

	// 현재 날짜와 시간을 출력한다.(c++20)
	auto time = floor<chrono::seconds>(chrono::system_clock::now());
	out << chrono::zoned_time("Asia/Seoul", time) << "\n";
	out << endl;


	// 읽을 파일의 정보를 읽어 쓸 파일에 덧붙여 쓴다.
	// 1. 파일의 내용을 벡터로 읽어온다
	vector<char> v{ istreambuf_iterator<char>{in}, {} };

	// 2. 벡터에 있는 내용을 파일에 복사한다.
	copy(v.begin(), v.end(), ostream_iterator<char>{out});

}

파일 이름 : 소스.cpp
파일크기:1772
2022-03-03 13:37:41 GMT+9



//-----------------------------------------------------------------------------
// 2022년 1학기 STL	3.2 수910	수910목56	 (1주 1일)
//
// - 강의소개
// - 교과서 - 사이트 : cppreference.com
// - 코딩스타일 : google coding convention
// - 프로젝트 환경 : Release/x64
//		메뉴 - 프로젝트  - 설정 - C++언어(초안기능)
//
// - Save 파일 만들기
//-----------------------------------------------------------------------------

#include <iostream>
#include <string_view>
#include <string_view>
#include <filesystem>
#include <chrono>
#include <fstream>
#include <vector>
#include <algorithm>

using namespace std;	// 이걸 안써야 하겠다.

void save(string_view);

int main()
{
	// string과 string_view 크기를 출력하라
	cout << "string의 크기 - " << sizeof(string) << "\n";
	cout << "string_view의 크기 - " << sizeof(string_view) << "\n";

	save("소스.cpp");
}

void save(string_view fname)
{
	// 읽을 파일을 연다.
	ifstream in{ fname.data() };

	// 쓸 파일도 연다.
	ofstream out{ "2022년 1학기 STL 수910 목56 강의저장.txt", ios::app };

	out << "\n\n";

	// 저장할 파일의 이름을 파일에 출력한다
	out << "파일 이름 : " << fname << "\n";

	// 저장할 파일의 크기를 출력한다(c++17)
	out << "파일크기:" << filesystem::file_size(fname) << "\n";

	// 현재 날짜와 시간을 출력한다.(c++20)
	auto time = floor<chrono::seconds>(chrono::system_clock::now());
	out << chrono::zoned_time("Asia/Seoul", time) << "\n";
	out << endl;


	// 읽을 파일의 정보를 읽어 쓸 파일에 덧붙여 쓴다.
	// 1. 컨테이너(자료구조) 파일의 내용을 벡터로 읽어온다
	vector<char> v{ istreambuf_iterator<char>{in}, {} };

	// 2. 알고리즘을 사용하여 벡터에 있는 내용을 파일에 복사(copy 알고리즘)한다.
	copy(v.begin(), v.end(), ostream_iterator<char>{out});

}

파일 이름 : 소스.cpp
파일크기:562
2022-03-03 13:43:20 GMT+9



//-----------------------------------------------------------------------------
// 2022년 1학기 STL	3.2 수910	수910목56	 (1주 1일)
//
// save 함수를 save.h와 save.cpp로 옮겨라
//-----------------------------------------------------------------------------

#include <iostream>
#include "save.h"

using namespace std;	// 이걸 안써야 하겠다.

int main()
{
	// string과 string_view 크기를 출력하라
	cout << "string의 크기 - " << sizeof(string) << "\n";
	cout << "string_view의 크기 - " << sizeof(string_view) << "\n";

	save("소스.cpp");
}



//-----------------------------------------------------------------------------------------------------------------파일 이름 : 소스.cpp
파일크기:560
2022-03-03 13:52:16 GMT+9

//-----------------------------------------------------------------------------
// 2022년 1학기 STL	3.2 수910	수910목56	 (1주 1일)
//
// save 함수를 save.h와 save.cpp로 옮겨라
//-----------------------------------------------------------------------------

#include <iostream>

#include "save.h"

using namespace std;	// 이걸 안써야 하겠다.

int main()
{
	// string과 string_view 크기를 출력하라
	cout << "string의 크기 - " << sizeof(string) << "\n";
	cout << "string_view의 크기 - " << sizeof(string_view) << "\n";

	save("소스.cpp");
}



//-----------------------------------------------------------------------------------------------------------------
파일 이름 : 소스.cpp
파일크기:434
2022-03-03 14:00:31 GMT+9

//-----------------------------------------------------------------------------
// 2022년 1학기 STL	3.2 수910	수910목56	 (1주 1일)
//
// save 함수를 save.h와 save.cpp로 옮겨라
//-----------------------------------------------------------------------------

#include <iostream>
#include "save.h"

using namespace std;	// 이걸 안써야 하겠다.

//-----------------
int main()
//-----------------
{
	save("소스.cpp");
}



//-----------------------------------------------------------------------------------------------------------------
파일 이름 : save.h
파일크기:69
2022-03-03 14:01:29 GMT+9

#pragma once
#include <string_view>

void save( std::string_view);

//-----------------------------------------------------------------------------------------------------------------
파일 이름 : save.cpp
파일크기:1433
2022-03-03 14:01:29 GMT+9

//-----------------------------------------------------------------------------
//SAVE.CPP
//
// 함수 save에 파일이름을 넘겨주면강의를 저장하는 
// "2022년 1학기 STL 수910 목56 강의저장.txt"에 덧붙여 기록한다.
//
// 3. 3
//

#include <fstream>
#include <chrono>
#include <filesystem>
#include <vector>
#include <algorithm>
#include "save.h"

void save( std::string_view fname)
{
	// 읽을 파일을 연다.
	std::ifstream in{ fname.data() };

	// 쓸 파일도 연다.
	std::ofstream out{ "2022년 1학기 STL 수910 목56 강의저장.txt", std::ios::app };

	out << "\n\n";
	out << "//-----------------------------------------------------------------------------------------------------------------\n";

	// 저장할 파일의 이름을 파일에 출력한다
	out << "파일 이름 : " << fname << "\n";

	// 저장할 파일의 크기를 출력한다(c++17)
	out << "파일크기:" << std::filesystem::file_size(fname) << "\n";

	// 현재 날짜와 시간을 출력한다.(c++20)
	auto time = floor<std::chrono::seconds>(std::chrono::system_clock::now());
	out << std::chrono::zoned_time("Asia/Seoul", time) << "\n";
	out << std::endl;


	// 읽을 파일의 정보를 읽어 쓸 파일에 덧붙여 쓴다.
	// 1. 컨테이너(자료구조) 파일의 내용을 벡터로 읽어온다
	std::vector<char> v{ std::istreambuf_iterator<char>{in}, {} };

	// 2. 알고리즘을 사용하여 벡터에 있는 내용을 파일에 복사(copy 알고리즘)한다.
	copy(v.begin(), v.end(), std::ostream_iterator<char>{out});

}

//-----------------------------------------------------------------------------------------------------------------
파일 이름 : 소스.cpp
파일크기:492
2022-03-03 14:01:29 GMT+9

//-----------------------------------------------------------------------------
// 2022년 1학기 STL	3.2 수910	수910목56	 (1주 1일)
//
// save 함수를 save.h와 save.cpp로 옮겨라
//-----------------------------------------------------------------------------

#include <iostream>
#include "save.h"

using namespace std;	// 이걸 안써야 하겠다.

//---------------------------
int main()
//---------------------------
{
	save("save.h");
	save("save.cpp");
	save("소스.cpp");
}



//----------------------------------------------------------<새로운 저장>-------------------------------------------------------
파일 이름 : save.h
파일크기:69
2022-03-03 14:03:56 GMT+9

#pragma once
#include <string_view>

void save( std::string_view);

//----------------------------------------------------------<새로운 저장>-------------------------------------------------------
파일 이름 : save.cpp
파일크기:1446
2022-03-03 14:03:56 GMT+9

//-----------------------------------------------------------------------------
//SAVE.CPP
//
// 함수 save에 파일이름을 넘겨주면강의를 저장하는 
// "2022년 1학기 STL 수910 목56 강의저장.txt"에 덧붙여 기록한다.
//
// 3. 3
//

#include <fstream>
#include <chrono>
#include <filesystem>
#include <vector>
#include <algorithm>
#include "save.h"

void save( std::string_view fname)
{
	// 읽을 파일을 연다.
	std::ifstream in{ fname.data() };

	// 쓸 파일도 연다.
	std::ofstream out{ "2022년 1학기 STL 수910 목56 강의저장.txt", std::ios::app };

	out << "\n\n";
	out << "//----------------------------------------------------------<새로운 저장>-------------------------------------------------------\n";

	// 저장할 파일의 이름을 파일에 출력한다
	out << "파일 이름 : " << fname << "\n";

	// 저장할 파일의 크기를 출력한다(c++17)
	out << "파일크기:" << std::filesystem::file_size(fname) << "\n";

	// 현재 날짜와 시간을 출력한다.(c++20)
	auto time = floor<std::chrono::seconds>(std::chrono::system_clock::now());
	out << std::chrono::zoned_time("Asia/Seoul", time) << "\n";
	out << std::endl;


	// 읽을 파일의 정보를 읽어 쓸 파일에 덧붙여 쓴다.
	// 1. 컨테이너(자료구조) 파일의 내용을 벡터로 읽어온다
	std::vector<char> v{ std::istreambuf_iterator<char>{in}, {} };

	// 2. 알고리즘을 사용하여 벡터에 있는 내용을 파일에 복사(copy 알고리즘)한다.
	copy(v.begin(), v.end(), std::ostream_iterator<char>{out});

}

//----------------------------------------------------------<새로운 저장>-------------------------------------------------------
파일 이름 : 소스.cpp
파일크기:503
2022-03-03 14:03:56 GMT+9

//------------------------------------<금일 강의 목표>----------------------------------
// 2022년 1학기 STL	3.3	수910목56 (1주 2일)
//
// save 함수를 save.h와 save.cpp로 옮겨라
//--------------------------------------------------------------------------------------

#include <iostream>
#include "save.h"

using namespace std;	// 이걸 안써야 하겠다.

//---------------------------
int main()
//---------------------------
{
	save("save.h");
	save("save.cpp");
	save("소스.cpp");
}



//----------------------------------------------------------<새로운 저장>-------------------------------------------------------
파일 이름 : 소스.cpp
파일크기:729
2022-03-03 14:06:17 GMT+9

//------------------------------------<금일 강의 목표>----------------------------------
// 2022년 1학기 STL	3.3	수910목56 (1주 2일)
//
// &의 의미
//--------------------------------------------------------------------------------------

#include <iostream>
#include "save.h"

using namespace std;	// 이걸 안써야 하겠다.

// [문제] main() 수정하면 안된다.
// a와 b의 값을 교환하라.  [출력] 2, 1

void change(int& a, int& b);

//---------------------------
int main()
//---------------------------
{
	int a{ 1 };
	int b{ 2 };

	change(a, b);

	cout << a << ", " << b << endl;

	save("소스.cpp");
}

void change(int& a, int& b) {
	int temp = a;
	a = b;
	b = temp;
}


//----------------------------------------------------------<새로운 저장>-------------------------------------------------------
파일 이름 : 소스.cpp
파일크기:1089
2022-03-03 15:13:03 GMT+9

//------------------------------------<금일 강의 목표>----------------------------------
// 2022년 1학기 STL	3.3	수910목56 (1주 2일)
//
// &의 의미
//--------------------------------------------------------------------------------------

#include <iostream>
#include "save.h"

using namespace std;	// 이걸 안써야 하겠다.

// [문제] main() 수정하면 안된다.
// a와 b의 값을 교환하라.  [출력] 2, 1
// 답지에 써라

class Dog {
private:
	int num;
public:
	Dog(int _num) : num(_num) {
	}

	friend ostream& operator<<(ostream& , const Dog& );

};

ostream& operator<<(ostream& os, const Dog& dog)
{
	os << dog.num;
	return os;
}

void change(int&, int&);
void change(Dog& , Dog& );

//---------------------------
int main()
//---------------------------
{
	Dog a{ 1 };
	Dog b{ 2 };

	change(a, b);

	cout << a << ", " << b << endl;
	// operator<<(cout, a);

	save("소스.cpp");
}

void change(int& a, int& b) {
	int temp{ a };
	a = b;
	b = temp;
}

void change(Dog& a, Dog& b) {
	Dog temp{ a };
	a = b;		// a.operator=(b);
	b = temp;
}


//----------------------------------------------------------<새로운 저장>-------------------------------------------------------
파일 이름 : 소스.cpp
파일크기:985
2022-03-03 15:15:45 GMT+9

//------------------------------------<금일 강의 목표>----------------------------------
// 2022년 1학기 STL	3.3	수910목56 (1주 2일)
//
// &의 의미
//--------------------------------------------------------------------------------------

#include <iostream>
#include "save.h"

using namespace std;	// 이걸 안써야 하겠다.

// [문제] main() 수정하면 안된다.
// a와 b의 값을 교환하라.  [출력] 2, 1
// 답지에 써라

class Dog {
private:
	int num;
public:
	Dog(int _num) : num(_num) {
	}

	operator int() {
		return num;
	}

};

void change(int&, int&);
void change(Dog& , Dog& );

//---------------------------
int main()
//---------------------------
{
	Dog a{ 1 };
	Dog b{ 2 };

	change(a, b);

	cout << a << ", " << b << endl;
	// operator<<(cout, a);

	save("소스.cpp");
}

void change(int& a, int& b) {
	int temp{ a };
	a = b;
	b = temp;
}

void change(Dog& a, Dog& b) {
	Dog temp{ a };
	a = b;		// a.operator=(b);
	b = temp;
}


//----------------------------------------------------------<새로운 저장>-------------------------------------------------------
파일 이름 : 소스.cpp
파일크기:1136
2022-03-10 13:37:53 GMT+9

//------------------------------------<금일 강의 목표>----------------------------------
// 2022년 1학기 STL	3.10	수910목56 (2주 1일)
//
// &의 의미
// class 복습 - special 함수의 의미
// 
// 다음시간 - templete
// 대량의 자료를 생성 저장 조작
//--------------------------------------------------------------------------------------

#include <iostream>
#include "save.h"

using namespace std;	// 이걸 안써야 하겠다.

// [문제] main() 수정하면 안된다.
// a와 b의 값을 교환하라.  [출력] 2, 1
// 답지에 써라

class Dog {
private:
	int num;
public:
	Dog(int _num) : num(_num) {
	}

	friend ostream& operator<<(ostream& os, const Dog& dog) {
		return os << dog.num;
	}

};

void change(int&, int&);
void change(Dog& , Dog& );

//---------------------------
int main()
//---------------------------
{
	Dog a{ 1 };
	Dog b{ 2 };

	change(a, b);

	cout << a << ", " << b << endl;
	// operator<<(cout, a);

	save("소스.cpp");
}

void change(int& a, int& b) {
	int temp{ a };
	a = b;
	b = temp;
}

void change(Dog& a, Dog& b) {
	Dog temp{ a };
	a = b;		// a.operator=(b);
	b = temp;
}


//----------------------------------------------------------<새로운 저장>-------------------------------------------------------
파일 이름 : 소스.cpp
파일크기:890
2022-03-10 13:43:28 GMT+9

//------------------------------------<금일 강의 목표>----------------------------------
// 2022년 1학기 STL	3.10	수910목56 (2주 1일)
//
// 이번시간 - templete
// 대량의 자료를 생성 저장 조작
//--------------------------------------------------------------------------------------

#include <iostream>
#include "save.h"
using namespace std;	// 이걸 안써야 하겠다.

//[문제] 템플릿 함수 change를 선언하고 정의하라.
//
//

template<typename T>
void change(T& a, T& b);

//---------------------------
int main()
//---------------------------
{
	{
		using namespace std::literals;
		int a{ 1 }, b{ 2 };
		change(a, b);
		cout << a << ", " << b << endl;
	}

	{
		string a{ "1"s }, b{ "2"s };
		change(a, b);
		cout << a << ", " << b << endl;
	}

	save("소스.cpp");
}

template<typename T>
void change(T& a, T& b) {
	T temp = a;
	a = b;
	b = temp;
}



//----------------------------------------------------------<새로운 저장>-------------------------------------------------------
파일 이름 : 소스.cpp
파일크기:1176
2022-03-10 13:59:09 GMT+9

//------------------------------------<금일 강의 목표>----------------------------------
// 2022년 1학기 STL	3.10	수910목56 (2주 1일)
//
// 이번시간 - templete
// 대량의 자료를 생성 저장 조작
//--------------------------------------------------------------------------------------

#include <iostream>
#include <algorithm>
#include "save.h"
using namespace std;	// 이걸 안써야 하겠다.

//[문제] 템플릿 함수 change를 선언하고 정의하라.
//템플릿은 선언과 동시에 정의을 해야한다.
// 역사적으로 템플릿을 선언과 정의를 분리할려고 시도했지만 실패했다.
//

template<class T>	//템플릿은 선언과 동시에 선언을 해야한다.
void change(T& a, T& b) {
	T temp{ a };
	a = b;
	b = temp;
}

void change(int& a, int& b) {
	cout << "이 함수가 무조건 1번 함수(템플릿은 우선순위가 낮다,)\n";
	cout << "즉 무조건 적으로 템플릿으로 함수를 확장 하지 않는다.\n";
	// void change(int, int) 와 같이 있으면 무엇을 불러와야 될지 모르기 때문에 오류가 난다.
}

//---------------------------
int main()
//---------------------------
{
	{
		using namespace std::literals;
		int a{ 1 }, b{ 2 };
		change(a, b);
		cout << a << ", " << b << endl;
	}

	{
		string a{ "1"s }, b{ "2"s };
		change(a, b);
		cout << a << ", " << b << endl;
	}

	save("소스.cpp");
}


//----------------------------------------------------------<새로운 저장>-------------------------------------------------------
파일 이름 : 소스.cpp
파일크기:1088
2022-03-10 14:54:29 GMT+9

//------------------------------------<금일 강의 목표>----------------------------------
// 2022년 1학기 STL	3.10	수910목56 (2주 1일)
// 
// 프로그래밍 패러다임 (언어가 지향하는 바) - 효율(시간->continuous, 공간->contiguous) 연속성
// c++	- Procedual Programming (c)
//		- Object Oriented Pr (c++)  UML
//		- Generic Pr (c++)
//		- Template Meta Pr -> 코드를 생성하는 코드
//		- Functional Pr -> 람다
//
// template - 자료형과 관계없는 함수 또는 클래스를 작성(keyword) 
//			- generic programming(일반적인 프로그래밍)
// 
// 대량의 자료를 생성 저장 조작
//--------------------------------------------------------------------------------------

#include <iostream>
#include <random>
#include <climits>
#include "save.h"
using namespace std;	// 이걸 안써야 하겠다.

//[문제] int의 최댁값을 출력하라
//

//---------------------------
int main()
//---------------------------
{
	cout << INT_MAX << "\n";
	cout << 0b01111111'11111111'11111111'11111111 << "\n";
	cout << 0x7FFFFFFF << "\n";
	cout << 0xFFFFFFFF << "\n";	// unsigned int

	save("소스.cpp");
}


//----------------------------------------------------------<새로운 저장>-------------------------------------------------------
파일 이름 : 소스.cpp
파일크기:990
2022-03-10 14:58:11 GMT+9

//------------------------------------<금일 강의 목표>----------------------------------
// 2022년 1학기 STL	3.10	수910목56 (2주 1일)
// 
// 프로그래밍 패러다임 (언어가 지향하는 바) - 효율(시간->continuous, 공간->contiguous) 연속성
// c++	- Procedual Programming (c)
//		- Object Oriented Pr (c++)  UML
//		- Generic Pr (c++)
//		- Template Meta Pr -> 코드를 생성하는 코드
//		- Functional Pr -> 람다
//
// template - 자료형과 관계없는 함수 또는 클래스를 작성(keyword) 
//			- generic programming(일반적인 프로그래밍)
// 
// 대량의 자료를 생성 저장 조작
//--------------------------------------------------------------------------------------

#include <iostream>
#include "save.h"
using namespace std;	// 이걸 안써야 하겠다.

//[문제] int의 최댁값을 출력하라
//

//---------------------------
int main()
//---------------------------
{
	int num = numeric_limits<int>::max();	//c++의 표준 방식

	cout << "int최댓값 - " << num << endl;

	save("소스.cpp");
}


//----------------------------------------------------------<새로운 저장>-------------------------------------------------------
파일 이름 : 소스.cpp
파일크기:1219
2022-03-10 15:19:59 GMT+9

//------------------------------------<금일 강의 목표>----------------------------------
// 2022년 1학기 STL	3.10	수910목56 (2주 1일)
// 
// 랜덤엔진과 분포를 사용하여 랜덤값을 생성한다.
// 대량의 자료를 생성 저장 조작
//--------------------------------------------------------------------------------------

#include <iostream>
#include <fstream>
#include <random>
#include "save.h"
using namespace std;	// 이걸 안써야 하겠다.

//[문제] 엔진과 분포를 사용하여 만든 int 1000개를
// "int 천개.txt" 파일에 저장하라

random_device rd;	//돌릴때 마다 랜덤으로 되도록 넣은 변수
default_random_engine dre{ rd() };	//(엔진) 약 2만 비트를 랜덤으로 바꿔주는놈

//---------------------------
int main()
//---------------------------
{
	uniform_int_distribution uid;	//(분포) 엔진의 확률을 조작하는 녀석, normal분포도 시험에 나올 수 있다.
		
	cout << "엔진 크기 - " << sizeof(dre) << endl;
	cout << "분포 크기 - " << sizeof(uid) << endl;

	ofstream out{ "int 천개.txt" };	//default모드는 ios::text 이다(두번째 인자).
	cout << "파일 스트림 객체의 크기 - " << sizeof(out) << " (=파일의 크기가 크다)" << endl;

	for (int i = 0; i < 1000; ++i) {
		out << uid(dre) << '\t';
	}

	save("소스.cpp");
}


//----------------------------------------------------------<새로운 저장>-------------------------------------------------------
파일 이름 : 소스.cpp
파일크기:875
2022-03-16 17:44:03 GMT+9

//------------------------------------<금일 강의 목표>----------------------------------
// 2022년 1학기 STL	3.16	수910목56 (2주 2일)
// 
//--------------------------------------------------------------------------------------

#include <iostream>
#include <fstream>
#include <random>
#include <format>	// C++20
#include "save.h"
using namespace std;	// 이걸 안써야 하겠다.

//[문제] 엔진과 분포를 사용하여 만든 int 1000개를
// "int 천개.txt" 파일에 저장하라

default_random_engine dre;	//(엔진) 약 2만 비트를 랜덤으로 바꿔주는놈

//---------------------------
int main()
//---------------------------
{
	uniform_int_distribution uid;

	ofstream out{ "int 천개.txt" };

	for (int i = 0; i < 1000; ++i) {
		cout << format( "{:^80}", uid(dre) );	// {:80}은 80칸 중 오른쪽에 {:<80}왼쪽에, {:^80}은 중간에 
	}
	cout << endl;

	save("소스.cpp");
}


//----------------------------------------------------------<새로운 저장>-------------------------------------------------------
파일 이름 : 소스.cpp
파일크기:916
2022-03-16 17:47:00 GMT+9

//------------------------------------<금일 강의 목표>----------------------------------
// 2022년 1학기 STL	3.16	수910목56 (2주 2일)
// 
//--------------------------------------------------------------------------------------

#include <iostream>
#include <fstream>
#include <random>
#include <format>	// C++20
#include "save.h"
using namespace std;	// 이걸 안써야 하겠다.

//[문제] 엔진과 분포를 사용하여 만든 int 1000개를
// "int 천개.txt" 파일에 저장하라

default_random_engine dre;	//(엔진) 약 2만 비트를 랜덤으로 바꿔주는놈

//---------------------------
int main()
//---------------------------
{
	uniform_int_distribution uid;

	ofstream out{ "int 천개.txt" };

	for (int i = 1; i <= 1000; ++i) {
		out << format( "{:19}", uid(dre) );	// {:80}은 80칸 중 오른쪽에 {:<80}왼쪽에, {:^80}은 중간에 
		if (i % 4 == 0) {
			out << endl;
		}
	}
	out << endl;

	save("소스.cpp");
}


//----------------------------------------------------------<새로운 저장>-------------------------------------------------------
파일 이름 : 소스.cpp
파일크기:883
2022-03-16 17:56:35 GMT+9

//------------------------------------<금일 강의 목표>----------------------------------
// 2022년 1학기 STL	3.16	수910목56 (2주 2일)
// 
//  파일에 있는 자료 읽어 오기
// 
//--------------------------------------------------------------------------------------

#include <iostream>
#include <fstream>
#include <vector>
#include "save.h"
using namespace std;	// 이걸 안써야 하겠다.

// [문제]  "int 천개.txt"에 있는 int 1000개를 읽어 화면에 출력하라.
//

//---------------------------
int main()
//---------------------------
{

	ifstream in("int 천개.txt");

	if (!in) {
		cout << "파일 열기 실패" << endl;
		return 0;
	}
	
	int num;
	for (int i{}; i < 1000; ++i) {
		in >> num;	// 공백과 문자를 구별하고 문자를 숫자로 바꾸는 고차원적인 연산을 수행함(시간 오래걸림)
		cout << num << "\t";
	}

	save("소스.cpp");
}


//----------------------------------------------------------<새로운 저장>-------------------------------------------------------
파일 이름 : 소스.cpp
파일크기:875
2022-03-16 18:02:27 GMT+9

//------------------------------------<금일 강의 목표>----------------------------------
// 2022년 1학기 STL	3.16	수910목56 (2주 2일)
// 
//  파일에 있는 자료 읽어 오기
// 
//--------------------------------------------------------------------------------------

#include <iostream>
#include <fstream>
#include <vector>
#include "save.h"
using namespace std;	// 이걸 안써야 하겠다.

// [문제]  "int 천개.txt"에 있는 int 1000개를 읽어 화면에 출력하라.
//	가장 큰 값을 찾아 화면에 출력하라.


//---------------------------
int main()
//---------------------------
{

	ifstream in("int 천개.txt");

	if (!in) {
		cout << "파일 열기 실패" << endl;
		return 0;
	}
	
	int maxi = INT_MIN;
	int num;
	for (int i{}; i < 1000; ++i) {
		in >> num;
		maxi = max(num, maxi);
		//cout << num << "\t";
	}
	cout << maxi << "\n";

	save("소스.cpp");
}


//----------------------------------------------------------<새로운 저장>-------------------------------------------------------
파일 이름 : 소스.cpp
파일크기:889
2022-03-16 18:07:27 GMT+9

//------------------------------------<금일 강의 목표>----------------------------------
// 2022년 1학기 STL	3.16	수910목56 (2주 2일)
// 
//  파일에 있는 자료 읽어 오기
// 
//--------------------------------------------------------------------------------------

#include <iostream>
#include <fstream>
#include <vector>
#include "save.h"
using namespace std;	// 이걸 안써야 하겠다.

// [문제]  "int 천개.txt"에 있는 int 1000개를 읽어 화면에 출력하라.
//	가장 큰 값을 찾아 화면에 출력하라.


//---------------------------
int main()
//---------------------------
{

	ifstream in("int 천개.txt");

	if (!in) {
		cout << "파일 열기 실패" << endl;
		return 0;
	}
	
	int max{ numeric_limits<int>::min() };
	int num;
	for (int i{}; i < 1000; ++i) {
		in >> num;
		if (max < num)
			max = num;
	}
	cout << "최댓값 - " << max << endl;

	save("소스.cpp");
}


//----------------------------------------------------------<새로운 저장>-------------------------------------------------------
파일 이름 : 소스.cpp
파일크기:832
2022-03-16 18:16:27 GMT+9

//------------------------------------<금일 강의 목표>----------------------------------
// 2022년 1학기 STL	3.16	수910목56 (2주 2일)
// 
//  파일에 있는 자료 읽어 오기
// 
//--------------------------------------------------------------------------------------

#include <iostream>
#include <fstream>
#include <algorithm>
#include <vector>
#include "save.h"
using namespace std;	// 이걸 안써야 하겠다.

// [문제]  "int 천개.txt"에 있는 int 1000개를 읽어 화면에 출력하라.
//	가장 큰 값을 찾아 화면에 출력하라.
//	코드를 답안지에 쓰고 출력되는 큰값도 답지에 적어라


//---------------------------
int main()
//---------------------------
{

	ifstream in{"int 천개.txt"};

	//여기에 들어갈 코드를 답지에 적어라.
	//간결하지만 속도도 빠르고 정확하다!!!
	cout << "최대값 - " << *max_element(istream_iterator<int>{in}, {}) << endl;

	save("소스.cpp");
}


//----------------------------------------------------------<새로운 저장>-------------------------------------------------------
파일 이름 : 소스.cpp
파일크기:671
2022-03-16 18:27:43 GMT+9

//------------------------------------<금일 강의 목표>----------------------------------
// 2022년 1학기 STL	3.16	수910목56 (2주 2일)
// 
//  파일에 있는 자료 읽어 오기
// 
//--------------------------------------------------------------------------------------

#include <iostream>
#include <fstream>
#include "save.h"
using namespace std;	// 이걸 안써야 하겠다.

// [문제]  int 1000개를 저장하는데 필요한 메모리는 몇 바이트입니까?
//			답 : 그때그때 다른다.(만든 사람 마음대로)
//			그렇지만 자료를 입출력하는데 가장 빠른방식은 저수준의 I/O를 사용
//

//---------------------------
int main()
//---------------------------
{
	save("소스.cpp");
}


//----------------------------------------------------------<새로운 저장>-------------------------------------------------------
파일 이름 : 소스.cpp
파일크기:937
2022-03-16 18:34:01 GMT+9

//------------------------------------<금일 강의 목표>----------------------------------
// 2022년 1학기 STL	3.16	수910목56 (2주 2일)
// 
//  파일에 있는 자료 읽어 오기
// 
//--------------------------------------------------------------------------------------

#include <iostream>
#include <fstream>
#include <random>
#include "save.h"
using namespace std;	// 이걸 안써야 하겠다.

// [문제]  int 1000개를 저장하는데 필요한 메모리는 몇 바이트입니까?
//			답 : 그때그때 다른다.(만든 사람 마음대로)
//			그렇지만 자료를 입출력하는데 가장 빠른방식은 저수준의 I/O를 사용
//

default_random_engine dre;
uniform_int_distribution uid;

//---------------------------
int main()
//---------------------------
{

	ofstream out{ "int 천개.txt" };

	int num;

	for ( int i{}; i < 1000; ++i) {
		num = uid(dre);
		out.write((const char*)&num, sizeof(int));	//num이라고 하는 시작번지에서
	}

	save("소스.cpp");
}


//----------------------------------------------------------<새로운 저장>-------------------------------------------------------
파일 이름 : 소스.cpp
파일크기:871
2022-03-16 18:35:23 GMT+9

//------------------------------------<금일 강의 목표>----------------------------------
// 2022년 1학기 STL	3.16	수910목56 (2주 2일)
// 
//  파일에 있는 자료 읽어 오기
// 
//--------------------------------------------------------------------------------------

#include <iostream>
#include <fstream>
#include <random>
#include "save.h"
using namespace std;	// 이걸 안써야 하겠다.

// [문제]  출력파일의 write 함수로 메모리 전체를 기록하였다.
// 파일 크기가 맞나 확인하고 그렇지 않다면 이유를 설명하라
//

default_random_engine dre;
uniform_int_distribution uid;

//---------------------------
int main()
//---------------------------
{

	ofstream out{ "int 천개.txt" };

	int num;

	for ( int i{}; i < 1000; ++i) {
		num = uid(dre);
		out.write((const char*)&num, sizeof(int));	//num이라고 하는 시작번지에서
	}

	save("소스.cpp");
}


//----------------------------------------------------------<새로운 저장>-------------------------------------------------------
파일 이름 : 소스.cpp
파일크기:878
2022-03-16 18:40:37 GMT+9

//------------------------------------<금일 강의 목표>----------------------------------
// 2022년 1학기 STL	3.16	수910목56 (2주 2일)
// 
//  파일에 있는 자료 읽어 오기
// 
//--------------------------------------------------------------------------------------

#include <iostream>
#include <fstream>
#include <random>
#include "save.h"
using namespace std;	// 이걸 안써야 하겠다.

// [문제]  출력파일의 write 함수로 메모리 전체를 기록하였다.
// 파일 크기가 맞나 확인하고 그렇지 않다면 이유를 설명하라
//

default_random_engine dre;
uniform_int_distribution uid(0,100);

//---------------------------
int main()
//---------------------------
{

	ofstream out{ "int 천개.txt" };

	int num;

	for ( int i{}; i < 1000; ++i) {
		num = uid(dre);
		out.write((const char*)&num, sizeof(int));	//num이라고 하는 시작번지에서
	}

	save("소스.cpp");
}


//----------------------------------------------------------<새로운 저장>-------------------------------------------------------
파일 이름 : 소스.cpp
파일크기:876
2022-03-16 18:41:14 GMT+9

//------------------------------------<금일 강의 목표>----------------------------------
// 2022년 1학기 STL	3.16	수910목56 (2주 2일)
// 
//  파일에 있는 자료 읽어 오기
// 
//--------------------------------------------------------------------------------------

#include <iostream>
#include <fstream>
#include <random>
#include "save.h"
using namespace std;	// 이걸 안써야 하겠다.

// [문제]  출력파일의 write 함수로 메모리 전체를 기록하였다.
// 파일 크기가 맞나 확인하고 그렇지 않다면 이유를 설명하라
//

default_random_engine dre;
uniform_int_distribution uid(0,0);

//---------------------------
int main()
//---------------------------
{

	ofstream out{ "int 천개.txt" };

	int num;

	for ( int i{}; i < 1000; ++i) {
		num = uid(dre);
		out.write((const char*)&num, sizeof(int));	//num이라고 하는 시작번지에서
	}

	save("소스.cpp");
}


//----------------------------------------------------------<새로운 저장>-------------------------------------------------------
파일 이름 : 소스.cpp
파일크기:876
2022-03-16 18:43:42 GMT+9

//------------------------------------<금일 강의 목표>----------------------------------
// 2022년 1학기 STL	3.16	수910목56 (2주 2일)
// 
//  파일에 있는 자료 읽어 오기
// 
//--------------------------------------------------------------------------------------

#include <iostream>
#include <fstream>
#include <random>
#include "save.h"
using namespace std;	// 이걸 안써야 하겠다.

// [문제]  출력파일의 write 함수로 메모리 전체를 기록하였다.
// 파일 크기가 맞나 확인하고 그렇지 않다면 이유를 설명하라
//

default_random_engine dre;
uniform_int_distribution uid(0,1);

//---------------------------
int main()
//---------------------------
{

	ofstream out{ "int 천개.txt" };

	int num;

	for ( int i{}; i < 1000; ++i) {
		num = uid(dre);
		out.write((const char*)&num, sizeof(int));	//num이라고 하는 시작번지에서
	}

	save("소스.cpp");
}


//----------------------------------------------------------<새로운 저장>-------------------------------------------------------
파일 이름 : 소스.cpp
파일크기:880
2022-03-16 18:45:36 GMT+9

//------------------------------------<금일 강의 목표>----------------------------------
// 2022년 1학기 STL	3.16	수910목56 (2주 2일)
// 
//  파일에 있는 자료 읽어 오기
// 
//--------------------------------------------------------------------------------------

#include <iostream>
#include <fstream>
#include <random>
#include "save.h"
using namespace std;	// 이걸 안써야 하겠다.

// [문제]  출력파일의 write 함수로 메모리 전체를 기록하였다.
// 파일 크기가 맞나 확인하고 그렇지 않다면 이유를 설명하라
//

default_random_engine dre;
uniform_int_distribution uid(0,10000);

//---------------------------
int main()
//---------------------------
{

	ofstream out{ "int 천개.txt" };

	int num;

	for ( int i{}; i < 1000; ++i) {
		num = uid(dre);
		out.write((const char*)&num, sizeof(int));	//num이라고 하는 시작번지에서
	}

	save("소스.cpp");
}


//----------------------------------------------------------<새로운 저장>-------------------------------------------------------
파일 이름 : 소스.cpp
파일크기:871
2022-03-16 18:46:40 GMT+9

//------------------------------------<금일 강의 목표>----------------------------------
// 2022년 1학기 STL	3.16	수910목56 (2주 2일)
// 
//  파일에 있는 자료 읽어 오기
// 
//--------------------------------------------------------------------------------------

#include <iostream>
#include <fstream>
#include <random>
#include "save.h"
using namespace std;	// 이걸 안써야 하겠다.

// [문제]  출력파일의 write 함수로 메모리 전체를 기록하였다.
// 파일 크기가 맞나 확인하고 그렇지 않다면 이유를 설명하라
//

default_random_engine dre;
uniform_int_distribution uid;

//---------------------------
int main()
//---------------------------
{

	ofstream out{ "int 천개.txt" };

	int num;

	for ( int i{}; i < 1000; ++i) {
		num = uid(dre);
		out.write((const char*)&num, sizeof(int));	//num이라고 하는 시작번지에서 4번 char크기로 쪼개서 저장한다.
	}

	save("소스.cpp");
}


//----------------------------------------------------------<새로운 저장>-------------------------------------------------------
파일 이름 : 소스.cpp
파일크기:1152
2022-03-16 18:53:09 GMT+9

//------------------------------------<금일 강의 목표>----------------------------------
// 2022년 1학기 STL	3.16	수910목56 (2주 2일)
// 
//  파일에 있는 자료 읽어 오기
// 
//--------------------------------------------------------------------------------------

#include <iostream>
#include <fstream>
#include <random>
#include "save.h"
using namespace std;	// 이걸 안써야 하겠다.

// [문제]  출력파일의 write 함수로 메모리 전체를 기록하였다.
// 파일 크기가 맞나 확인하고 그렇지 않다면 이유를 설명하라
//

default_random_engine dre;
uniform_int_distribution uid;

//---------------------------
int main()
//---------------------------
{

	ofstream out{ "int 천개.txt", ios::binary };

	int num;

	for ( int i{}; i < 1000; ++i) {
		num = uid(dre);
		out.write((const char*)&num, sizeof(int));	//num이라고 하는 시작번지에서 4번 char크기로 쪼개서 저장한다.
		//정확히 4000바이트를 저장하지 않는다... 왜:
		//엔터가는 문자가 왔을때, 2바이트를 사용한다(엔터를 나타내는것과 다음줄로 넘기는 너셕둘다 저장?되기 때문)
		// 파일을 열때 ios::binary 를 쓸경우 (엔터에 장난치지 않고) 그대로 저장한다
	}

	save("소스.cpp");
}


//----------------------------------------------------------<새로운 저장>-------------------------------------------------------
파일 이름 : 소스.cpp
파일크기:951
2022-03-16 19:06:20 GMT+9

//------------------------------------<금일 강의 목표>----------------------------------
// 2022년 1학기 STL	3.16	수910목56 (2주 2일)
// 
//  파일에 있는 자료 읽어 오기
// 
//--------------------------------------------------------------------------------------

#include <iostream>
#include <fstream>
#include <vector>
#include <algorithm>
#include "save.h"
using namespace std;	// 이걸 안써야 하겠다.

// [문제] 파일 "int 천개.txt" - int 값 1000개가 바이너리 모드로 write() 함수로 기록
// 읽어서 최대값을 출력하시오
//  코드와 출력값을 답지에 적어라
//

//---------------------------
int main()
//---------------------------
{

	ifstream in{ "int 천개.txt", ios::binary };

	vector<int> v;
	int num;
	for (int i{}; i < 1000; ++i) {	// 이것은 비효율적인 코드이다.
		//read로 int하나의 데이터를 가져와서 num에 저장하기 때문에
		in.read((char*)&num, sizeof(int));
		v.push_back(num);
	}

	cout << "최댓값 - " << *max_element(v.begin(), v.end()) << endl;

	save("소스.cpp");
}


//----------------------------------------------------------<새로운 저장>-------------------------------------------------------
파일 이름 : 소스.cpp
파일크기:950
2022-03-16 19:13:54 GMT+9

//------------------------------------<금일 강의 목표>----------------------------------
// 2022년 1학기 STL	3.16	수910목56 (2주 2일)
// 
//  파일에 있는 자료 읽어 오기
// 
//--------------------------------------------------------------------------------------

#include <iostream>
#include <fstream>
#include <algorithm>
#include "save.h"
using namespace std;	// 이걸 안써야 하겠다.

// [문제] 파일 "int 천개.txt" - int 값 1000개가 바이너리 모드로 write() 함수로 기록
// 읽어서 최대값을 출력하시오
//  코드와 출력값을 답지에 적어라
//

//---------------------------
int main()
//---------------------------
{

	ifstream in{ "int 천개.txt", ios::binary };

	//DMA : cpu가 관여할 여지 없시 직접적으로 메모리를 억세스하여 옮겨 버린다.
	int num[1000];	//이런건 안전하지 않아서 쓰지말자
	in.read((char*)num, sizeof(int) * 1000);	// 4000bytes를 한번에 옮겨서 cpu가 관여하지 않도록한다.

	cout << *max_element( begin(num), end(num));

	save("소스.cpp");
}


//----------------------------------------------------------<새로운 저장>-------------------------------------------------------
파일 이름 : 소스.cpp
파일크기:1046
2022-03-16 19:18:12 GMT+9

//------------------------------------<금일 강의 목표>----------------------------------
// 2022년 1학기 STL	3.16	수910목56 (2주 2일)
// 
//  파일에 있는 자료 읽어 오기
// 
//--------------------------------------------------------------------------------------

#include <iostream>
#include <fstream>
#include <algorithm>
#include <array>
#include "save.h"
using namespace std;	// 이걸 안써야 하겠다.

// [문제] 파일 "int 천개.txt" - int 값 1000개가 바이너리 모드로 write() 함수로 기록
// 읽어서 최대값을 출력하시오
//  코드와 출력값을 답지에 적어라
//

//---------------------------
int main()
//---------------------------
{

	ifstream in{ "int 천개.txt", ios::binary };

	//DMA : cpu가 관여할 여지 없시 직접적으로 메모리를 억세스하여 옮겨 버린다.
	array<int, 1000> num;	// 앞으로 int num[1000]; 사용하지 말자 (이유:클래스로 포장해놔서)
	in.read((char*)num.data(), sizeof(int) * 1000);	// 4000bytes를 한번에 옮겨서 cpu가 관여하지 않도록한다.
	cout << *max_element( begin(num), end(num));

	save("소스.cpp");
}


//----------------------------------------------------------<새로운 저장>-------------------------------------------------------
파일 이름 : 소스.cpp
파일크기:1625
2022-03-17 14:15:10 GMT+9

//------------------------------------<금일 강의 목표>----------------------------------
// 2022년 1학기 STL	3.17	수910목56 (3주 1일)
// 
// 지난 시간 - int[10] 쓰지 말자 --> 대신 array<int,10> 쓰자
// 
// 오늘 - C++ 컴파일러가 값을 아는 시점
//			1. 실행하기 전 - compile time - constexpr
//			2. 실행한 후 - run time 시에 결정되는 값 - dynamic allocation
// 
// 메인의 괄호안에 - STACK -> 지역이 끝나면 메모리가 사라진다.
// 전역부분 - DATA
// 따로 노는곳 - Free  store -> new로 메모리를 할당해야한다.
// 
//--------------------------------------------------------------------------------------

#include <iostream>
#include <vector>
#include <numeric>
#include "save.h"

#define lli long long int

using namespace std;	// 이걸 안써야 하겠다.

// [문제] 사용자가 입력한 숫자만큼 int를 저장할 수 있는 메모리를 만들고 
// 메모리값을 1부터 채운다.( 시점을 묻는 문제 )
// 합계를 출력하라.
// 이 과정을 반복하라 - 문제점을 해결하라
//
// 합계가 int-max를 넘지않는 num을 구하는 문제가 시험으로 나올수 있다.

//---------------------------
int main()
//---------------------------
{
	save("소스.cpp");
	
	while (true) {
		int num;
		cout << "int 몇개를 저장할까요? ";
		cin >> num;


		//여기에 들어갈 코드를 답지에 적어라
		int* p = new int[num]; // new는 contiguous(붙어있는) 메모리를 할당하고 시작점을 리턴해준다.
		
		for (int i{}; i < num; ++i) {
			p[i] = i + 1;
		}

		// 합계를 구해 출력
		cout << "합:" << accumulate<int*, lli>(p, p + num, 0) << "\n";

		//int sum{};
		//for (int i{}; i < num; ++i) {
		//	sum += p[i];
		//}
		//cout << "1부터 " << num << " 까지 합계는 - " << sum << endl;

		delete[] p;	//메모리 해제

	}

	
}


//----------------------------------------------------------<새로운 저장>-------------------------------------------------------
파일 이름 : 소스.cpp
파일크기:1115
2022-03-17 14:47:49 GMT+9

//------------------------------------<금일 강의 목표>----------------------------------
// 2022년 1학기 STL	3.17	수910목56 (3주 1일)
// 
// 지난 시간 - int[10] 쓰지 말자 --> 대신 array<int,10> 쓰자
// 지금 시간 - int* 쓰지말자
// 오늘 - C++ 컴파일러가 값을 아는 시점
//			1. 실행하기 전 - compile time - constexpr
//			2. 실행한 후 - run time 시에 결정되는 값 - dynamic allocation
// 
// 
// 메인의 괄호안에 - STACK -> 지역이 끝나면 메모리가 사라진다.
// 전역부분 - DATA
// 따로 노는곳 - Free  store -> new로 메모리를 할당해야한다.
// 
//--------------------------------------------------------------------------------------

#include <iostream>
#include "save.h"

using namespace std;	// 이걸 안써야 하겠다.

// [실습] 스마트 포인터가 어떤지 관찰한다
// 객체의 생성과 소멸 관찰이 필수이므로 초미니 클래스를 만들어 동작 관찰 
//

struct Dog {
	Dog() { cout << "Dog 생성" << endl; }
	~Dog() { cout << "Dog 소멸" << endl; }
};

//---------------------------
int main()
//---------------------------
{

	Dog* p = new Dog[3];

	// 사용


	save("소스.cpp");
	
	delete p;

}


//----------------------------------------------------------<새로운 저장>-------------------------------------------------------
파일 이름 : 소스.cpp
파일크기:1172
2022-03-17 14:53:29 GMT+9

//------------------------------------<금일 강의 목표>----------------------------------
// 2022년 1학기 STL	3.17	수910목56 (3주 1일)
// 
// 지난 시간 - int[10] 쓰지 말자 --> 대신 array<int,10> 쓰자
// 지금 시간 - int* 쓰지말자
// 오늘 - C++ 컴파일러가 값을 아는 시점
//			1. 실행하기 전 - compile time - constexpr
//			2. 실행한 후 - run time 시에 결정되는 값 - dynamic allocation
// 
// 
// 메인의 괄호안에 - STACK -> 지역이 끝나면 메모리가 사라진다.
// 전역부분 - DATA
// 따로 노는곳 - Free  store -> new로 메모리를 할당해야한다.
// 
//--------------------------------------------------------------------------------------

#include <iostream>
#include "save.h"

using namespace std;	// 이걸 안써야 하겠다.

// [실습] 스마트 포인터가 어떤지 관찰한다
// 객체의 생성과 소멸 관찰이 필수이므로 초미니 클래스를 만들어 동작 관찰 
//

struct Dog {
	Dog() { cout << "Dog 생성" << endl; }
	~Dog() { cout << "Dog 소멸" << endl; }
};

void f()
{
	throw 1;
}

//---------------------------
int main()
//---------------------------
{

	save("소스.cpp");

	Dog* p = new Dog[3];
	f( );	// 예외를 던지는 함수 발생

	
	
	delete[] p;

}


//----------------------------------------------------------<새로운 저장>-------------------------------------------------------
파일 이름 : 소스.cpp
파일크기:1326
2022-03-17 14:55:33 GMT+9

//------------------------------------<금일 강의 목표>----------------------------------
// 2022년 1학기 STL	3.17	수910목56 (3주 1일)
// 
// 지난 시간 - int[10] 쓰지 말자 --> 대신 array<int,10> 쓰자
// 지금 시간 - int* 쓰지말자
// 오늘 - C++ 컴파일러가 값을 아는 시점
//			1. 실행하기 전 - compile time - constexpr
//			2. 실행한 후 - run time 시에 결정되는 값 - dynamic allocation
// 
// 
// 메인의 괄호안에 - STACK -> 지역이 끝나면 메모리가 사라진다.
// 전역부분 - DATA
// 따로 노는곳 - Free  store -> new로 메모리를 할당해야한다.
// 
//--------------------------------------------------------------------------------------

#include <iostream>
#include "save.h"

using namespace std;	// 이걸 안써야 하겠다.

// [실습] 스마트 포인터가 어떤지 관찰한다
// 객체의 생성과 소멸 관찰이 필수이므로 초미니 클래스를 만들어 동작 관찰 
//

struct Dog {
	Dog() { cout << "Dog 생성" << endl; }
	~Dog() { cout << "Dog 소멸" << endl; }
};

void f()
{
	throw 1;
}

//---------------------------
int main()
//---------------------------
{

	save("소스.cpp");

	Dog* p = new Dog[3];

	try {
		f();	// 예외를 던지는 함수 발생
	}
	catch (...) {	// -> ellipses
		delete[] p;	//제어의 흐름이 이쪽으로 빠질수도 있으니 여기서도 메모리 반환으르 해줘야 한다.
		return 0;
	}
	
	
	delete[] p;

}


//----------------------------------------------------------<새로운 저장>-------------------------------------------------------
파일 이름 : 소스.cpp
파일크기:1293
2022-03-17 15:03:18 GMT+9

//------------------------------------<금일 강의 목표>----------------------------------
// 2022년 1학기 STL	3.17	수910목56 (3주 1일)
// 
// 지난 시간 - int[10] 쓰지 말자 --> 대신 array<int,10> 쓰자
// 지금 시간 - int* 쓰지말자
// 오늘 - C++ 컴파일러가 값을 아는 시점
//			1. 실행하기 전 - compile time - constexpr
//			2. 실행한 후 - run time 시에 결정되는 값 - dynamic allocation
// 
// 
// 메인의 괄호안에 - STACK -> 지역이 끝나면 메모리가 사라진다.
// 전역부분 - DATA
// 따로 노는곳 - Free  store -> new로 메모리를 할당해야한다.
// 
//--------------------------------------------------------------------------------------

#include <iostream>
#include <memory>
#include "save.h"

using namespace std;	// 이걸 안써야 하겠다.

// [실습] 스마트 포인터가 어떤지 관찰한다
// 객체의 생성과 소멸 관찰이 필수이므로 초미니 클래스를 만들어 동작 관찰 
//

struct Dog {
	Dog() { cout << "Dog 생성" << endl; }
	~Dog() { cout << "Dog 소멸" << endl; }
};

void f()
{
	throw 1;
}

//---------------------------
int main()
//---------------------------
{
	save("소스.cpp");

	// RAII(raii)로 자동화
	unique_ptr<Dog[]> p{new Dog[3]};

	// 전통적으로 예외를 처리하는 방식
	try {
		f();	// 예외를 던지는 함수 발생
	}
	catch (...) {
		return 0;	// stack unwinding(스택 풀기) 스택을 거슬러 지역에 만들어지 객체를 소멸시켜준다.
	}

	

}


//----------------------------------------------------------<새로운 저장>-------------------------------------------------------
파일 이름 : 소스.cpp
파일크기:893
2022-03-23 17:54:10 GMT+9

//------------------------------------<금일 강의 목표>----------------------------------
// 2022년 1학기 STL	3.23	수910목56 (3주 2일)
// 
// 지난시간 - RAII / Stack unwinding : 자원이 깔끔하게 제어가 된다.
// 
// 호출가능타입(Callable type) - sort를 통해 알아본다
// 
//--------------------------------------------------------------------------------------

#include <iostream>
#include <fstream>
#include "save.h"

using namespace std;	// 이걸 안써야 하겠다.

// [문제] "소스.cpp"를 읽어서
// 소문자를 대문자로 바꿔
// "소스 대문자.cpp"로 저장하라
//


//---------------------------
int main()
//---------------------------
{
	
	ifstream in{ "소스.cpp" };

	char ch;

	in >> noskipws;	// wide space? 공백(개행문자 등)을 스킵하지 마라
	while (in >> ch) {
		ch = toupper(ch);
		cout << ch;	//일단 먼저 화면에 출력해보자
	}

	save("소스.cpp");

}


//----------------------------------------------------------<새로운 저장>-------------------------------------------------------
파일 이름 : 소스.cpp
파일크기:920
2022-03-23 17:55:31 GMT+9

//------------------------------------<금일 강의 목표>----------------------------------
// 2022년 1학기 STL	3.23	수910목56 (3주 2일)
// 
// 지난시간 - RAII / Stack unwinding : 자원이 깔끔하게 제어가 된다.
// 
// 호출가능타입(Callable type) - sort를 통해 알아본다
// 
//--------------------------------------------------------------------------------------

#include <iostream>
#include <fstream>
#include "save.h"

using namespace std;	// 이걸 안써야 하겠다.

// [문제] "소스.cpp"를 읽어서
// 소문자를 대문자로 바꿔
// "소스 대문자.cpp"로 저장하라
//


//---------------------------
int main()
//---------------------------
{
	
	ifstream in{ "소스.cpp" };
	ofstream out{ "소스 대문자.cpp" };

	char ch;

	//잘했지만, 루프를 직접쓰지말고 알고리즘을 쓰자
	in >> noskipws;	// wide space? 공백(개행문자 등)을 스킵하지 마라
	while (in >> ch) {
		ch = toupper(ch);
		out << ch;	//일단 먼저 화면에 출력해보자
	}

	save("소스.cpp");

}


//----------------------------------------------------------<새로운 저장>-------------------------------------------------------
파일 이름 : 소스.cpp
파일크기:1019
2022-03-23 18:11:54 GMT+9

//------------------------------------<금일 강의 목표>----------------------------------
// 2022년 1학기 STL	3.23	수910목56 (3주 2일)
// 
// 지난시간 - RAII / Stack unwinding : 자원이 깔끔하게 제어가 된다.
// 
// 호출가능타입(Callable type) - sort를 통해 알아본다
// 
//--------------------------------------------------------------------------------------

#include <iostream>
#include <fstream>
#include <algorithm>
#include "save.h"

using namespace std;	// 이걸 안써야 하겠다.

// [문제] "소스.cpp"를 읽어서
// 소문자를 대문자로 바꿔
// "소스 대문자.cpp"로 저장하라
//


//---------------------------
int main()
//---------------------------
{
	
	ifstream in{ "소스.cpp" };
	ofstream out{ "소스 대문자.cpp" };

	char ch;

	transform(istreambuf_iterator<char>{in}, 
		{},		// {}를 넣으면 끝을 나타냄
		ostreambuf_iterator<char>{cout}, 
		[](char c) {
			return toupper(c);
		});	// auto가 들어간걸 제네릭 람다라고 한다.(본질이 흐려져서 추전하진 않음)

	save("소스.cpp");

}


//----------------------------------------------------------<새로운 저장>-------------------------------------------------------
파일 이름 : 소스.cpp
파일크기:983
2022-03-23 18:17:10 GMT+9

//------------------------------------<금일 강의 목표>----------------------------------
// 2022년 1학기 STL	3.23	수910목56 (3주 2일)
// 
// 지난시간 - RAII / Stack unwinding : 자원이 깔끔하게 제어가 된다.
// 
// 호출가능타입(Callable type) - sort를 통해 알아본다
// 
//--------------------------------------------------------------------------------------

#include <iostream>
#include <fstream>
#include <algorithm>
#include "save.h"

using namespace std;	// 이걸 안써야 하겠다.

// [문제] "소스.cpp"를 읽어서
// 소문자를 대문자로 바꿔
// "소스 대문자.cpp"로 저장하라
//


//---------------------------
int main()
//---------------------------
{
	
	ifstream in{ "소스.cpp" };
	ofstream out{ "소스 대문자.cpp" };

	char ch;

	transform(istreambuf_iterator<char>{in}, 
		{}, // {}를 넣으면 끝을 나타냄
		ostreambuf_iterator<char>{cout}, 
		[](char c) {
			if (isdigit(c)) {
				c = '*';
			}
			return c;
		});

	save("소스.cpp");

}




//----------------------------------------------------------<새로운 저장>-------------------------------------------------------
파일 이름 : 소스.cpp
파일크기:979
2022-03-23 18:17:58 GMT+9

//------------------------------------<금일 강의 목표>----------------------------------
// 2022년 1학기 STL	3.23	수910목56 (3주 2일)
// 
// 지난시간 - RAII / Stack unwinding : 자원이 깔끔하게 제어가 된다.
// 
// 호출가능타입(Callable type) - sort를 통해 알아본다
// 
//--------------------------------------------------------------------------------------

#include <iostream>
#include <fstream>
#include <algorithm>
#include "save.h"

using namespace std;	// 이걸 안써야 하겠다.

// [문제] "소스.cpp"를 읽어서
// 소문자를 대문자로 바꿔
// "소스 대문자.cpp"로 저장하라
//


//---------------------------
int main()
//---------------------------
{
	
	ifstream in{ "소스.cpp" };
	ofstream out{ "소스 대문자.cpp" };

	char ch;

	transform(istreambuf_iterator<char>{in}, 
		{}, // {}를 넣으면 끝을 나타냄
		ostreambuf_iterator<char>{cout}, 
		[](char c) {
			if (isalnum(c)) {
				c++;
			}
			return c;
		});

	save("소스.cpp");

}




//----------------------------------------------------------<새로운 저장>-------------------------------------------------------
파일 이름 : 소스.cpp
파일크기:1256
2022-03-23 18:43:58 GMT+9

//------------------------------------<금일 강의 목표>----------------------------------
// 2022년 1학기 STL	3.23	수910목56 (3주 2일)
// 
// 호출가능타입(Callable type) - sort를 통해 알아본다
// 자원을 확보하는 관찰용 클래스 STRING - 컨테이너/반복자/알고리즘
// contiguous memory는 붙어있기 때문에 []를 쓸수 있고 접는하는데 시간복잡도는 O(1)이다.
// 
//--------------------------------------------------------------------------------------

#include <iostream>
#include <array>
#include <random>
#include <algorithm>
#include <format>
#include "save.h"

using namespace std;	// 이걸 안써야 하겠다.

// [문제] [1,100] 랜덤 int 100개를 생성한다.
// 오름차순으로 정렬하라. sort
// 정렬된 int 100개를 생성하라
//

random_device rd;
default_random_engine dre{ rd() };
uniform_int_distribution uid(1,100);

//---------------------------
int main()
//---------------------------
{
	array<int, 100> numbers;

	for (int& number : numbers)
		number = uid(dre);

	cout << "정렬하기 전" << endl;
	for (int number : numbers)
		cout << format("{:20}", number);

	sort(numbers.begin(), numbers.end());

	cout << "정렬 후" << endl;
	for (int number : numbers)
		cout << format("{:20}", number) ;

	save("소스.cpp");

}




//----------------------------------------------------------<새로운 저장>-------------------------------------------------------
파일 이름 : 소스.cpp
파일크기:1269
2022-03-23 19:01:57 GMT+9

//------------------------------------<금일 강의 목표>----------------------------------
// 2022년 1학기 STL	3.23	수910목56 (3주 2일)
// 
// 호출가능타입(Callable type) - sort를 통해 알아본다
// 자원을 확보하는 관찰용 클래스 STRING - 컨테이너/반복자/알고리즘
// contiguous memory는 붙어있기 때문에 []를 쓸수 있고 접는하는데 시간복잡도는 O(1)이다.
// 
//--------------------------------------------------------------------------------------

#include <iostream>
#include <array>
#include <random>
#include <algorithm>
#include <format>
#include "save.h"

using namespace std;	// 이걸 안써야 하겠다.

// [문제] [1,100] 랜덤 int 100개를 생성한다.
// 오름차순으로 정렬하라. sort
// 정렬된 int 100개를 생성하라
//

random_device rd;
default_random_engine dre{ rd() };
uniform_int_distribution uid{ 1,100 };

//---------------------------
int main()
//---------------------------
{
	array<int, 100> numbers;

	for (int& number : numbers)
		number = uid(dre);

	cout << "정렬하기 전" << endl;
	for (int number : numbers)
		cout << format("{:4}", number);

	sort(numbers.begin(), numbers.end(), 내림);

	cout << "정렬 후" << endl;
	for (int number : numbers)
		cout << format("{:4}", number) ;

	save("소스.cpp");

}




//----------------------------------------------------------<새로운 저장>-------------------------------------------------------
파일 이름 : 소스.cpp
파일크기:1067
2022-03-23 19:14:14 GMT+9

//------------------------------------<금일 강의 목표>----------------------------------
// 2022년 1학기 STL	3.23	수910목56 (3주 2일)
// 
// 호출가능타입(Callable type) - sort를 통해 알아본다
// 자원을 확보하는 관찰용 클래스 STRING - 컨테이너/반복자/알고리즘
// contiguous memory는 붙어있기 때문에 []를 쓸수 있고 접는하는데 시간복잡도는 O(1)이다.
// 
//--------------------------------------------------------------------------------------

#include <iostream>
#include "save.h"

using namespace std;	// 이걸 안써야 하겠다.

// 메모리 마지막 동네 소개
// 1 Stack
// 2 DATA
// 3 Free Store
// 4 CODE  :  코드가 들어있는 메모리 공간
// 프로그램을 실행할때 1, 2, 4번은 통째로 메모리에 올라간다.
// 함수가 불리면 CODE부분에 가서 실행하고 돌아온다.
// 함수이름 = 함수의 시작번지
// 

void f() {
	cout << "f 호출" << endl;
}

//---------------------------
int main()
//---------------------------
{
	f();

	//코드는 다 같은 동네(메모리상 가까운곳)에 있다.
	cout << addressof(f) << endl;
	cout << addressof(main) << endl;
	cout << addressof(save) << endl;

	save("소스.cpp");

}




//----------------------------------------------------------<새로운 저장>-------------------------------------------------------
파일 이름 : 소스.cpp
파일크기:927
2022-03-24 13:37:05 GMT+9

//------------------------------------<금일 강의 목표>----------------------------------
// 2022년 1학기 STL	3.24	수910목56 (4주 1일)
// 
// 호출가능타입(Callable type) - sort를 통해 알아본다
// 자원을 확보하는 관찰용 클래스 STRING - 컨테이너/반복자/알고리즘
// contiguous memory는 붙어있기 때문에 []를 쓸수 있고 접는하는데 시간복잡도는 O(1)이다.
// 
//--------------------------------------------------------------------------------------

#include <iostream>
#include "save.h"

using namespace std;	// 이걸 안써야 하겠다.

void f() {
	cout << "f 호출" << endl;
}

//---------------------------
int main()
//---------------------------
{
	// 함수이름이란? - 명령어들의 집합인 함수가 기록되어 있는
	// CODE 세그먼트의 시작번지이다.
	// 함수의 이름의 자료형 (data type)
	//

	auto x = main;	//자료형이 같을때 = 기호를 쓸 수 있으므로
	cout << typeid(x).name() << endl;

	save("소스.cpp");

}




//----------------------------------------------------------<새로운 저장>-------------------------------------------------------
파일 이름 : 소스.cpp
파일크기:1122
2022-03-24 13:44:07 GMT+9

//------------------------------------<금일 강의 목표>----------------------------------
// 2022년 1학기 STL	3.24	수910목56 (4주 1일)
// 
// 호출가능타입(Callable type) - sort를 통해 알아본다
// 자원을 확보하는 관찰용 클래스 STRING - 컨테이너/반복자/알고리즘
// contiguous memory는 붙어있기 때문에 []를 쓸수 있고 접는하는데 시간복잡도는 O(1)이다.
// 
//--------------------------------------------------------------------------------------

#include <iostream>
#include "save.h"

using namespace std;	// 이걸 안써야 하겠다.

void f() {
	cout << "f 호출" << endl;
}

//---------------------------
int main()
//---------------------------
{
	// 함수이름이란? - 명령어들의 집합인 함수가 기록되어 있는
	// CODE 세그먼트의 시작번지이다.
	// 함수의 이름의 자료형 (data type)은 무엇입니까?
	//  -> 함수포인터 ( 8byte )
	//
	int aa[100];	// 변수이름을 적는 위치가 예외인 경우 1 => int[100] aa; 라고 적지 않는다.
	cout << typeid(aa).name() << endl;

	int(*x)(void)  = (int(*)(void))main;	// 	// 변수이름을 적는 위치가 예외인 경우 2 => int(*)(void) x; 라고 적지 않는다.

	save("소스.cpp");

}




//----------------------------------------------------------<새로운 저장>-------------------------------------------------------
파일 이름 : 소스.cpp
파일크기:1234
2022-03-24 13:58:36 GMT+9

//------------------------------------<금일 강의 목표>----------------------------------
// 2022년 1학기 STL	3.24	수910목56 (4주 1일)
// 
// 호출가능타입(Callable type) - sort를 통해 알아본다
// 자원을 확보하는 관찰용 클래스 STRING - 컨테이너/반복자/알고리즘
// contiguous memory는 붙어있기 때문에 []를 쓸수 있고 접는하는데 시간복잡도는 O(1)이다.
// 
//--------------------------------------------------------------------------------------

#include <iostream>
#include <thread>
#include "save.h"

using namespace std;	// 이걸 안써야 하겠다.

// [문제] 호출가능(Callable) 타입(type)
// 1. 함수 포인터 - CODE에서 해당 함수의 시작번지를 저장		//주의! "함수"라고 하면 안됨!!
// 

void jump() {
	cout << "점프" << endl;
}

void slide() {
	cout << "슬라이드" << endl;
}

int cnt{};

//---------------------------
int main()
//---------------------------
{
	save("소스.cpp");

	void(*p)(void) = jump;

	while (true) {
		p();

		//아래 sleep_for는 cpu를 다른 녀석에게 넘겨주지 않고 계속 잡기 때문에 실전에서 쓰면 안된다.
		this_thread::sleep_for(1s);	// std::literals

		// 3초마다 toggle
		
		if (++cnt % 3 == 0) {
			if (p == jump)
				p = slide;
			else
				p = jump;
		}

	}

}




//----------------------------------------------------------<새로운 저장>-------------------------------------------------------
파일 이름 : 소스.cpp
파일크기:1473
2022-03-24 14:09:06 GMT+9

//------------------------------------<금일 강의 목표>----------------------------------
// 2022년 1학기 STL	3.24	수910목56 (4주 1일)
// 
// 호출가능타입(Callable type) - sort를 통해 알아본다
// 자원을 확보하는 관찰용 클래스 STRING - 컨테이너/반복자/알고리즘
// contiguous memory는 붙어있기 때문에 []를 쓸수 있고 접는하는데 시간복잡도는 O(1)이다.
// 
//--------------------------------------------------------------------------------------

#include <iostream>
#include <thread>
#include "save.h"

using namespace std;	// 이걸 안써야 하겠다.

// [문제] 호출가능(Callable) 타입(type)
// 1. 함수 포인터 - CODE에서 해당 함수의 시작번지를 저장		//주의! "함수"라고 하면 안됨!!
// 

void jump() {
	cout << "점프" << endl;
}

int g;

//---------------------------
int main()
//---------------------------
{
	void(*p)(void) = jump;

	int cnt{};

	int* f = new int;

	cout << "CODE       -  jump : " << addressof(jump) << endl;
	cout << "CODE       -  main : " << addressof(main) << endl;
	cout << "CODE       -  save : " << addressof(save) << endl;
	cout << "CODE       -  p점프: " << addressof(*p) << endl;	//jump의 번지와 같다.
	cout << endl;
	cout << "DATA       -  g    : " << addressof(g) << endl;
	cout << endl;
	cout << "STACK      -  p    : " << addressof(p) << endl;
	cout << "STACK      -  f    : " << addressof(f) << endl;
	cout << endl;
	cout << "FREE STORE - *f    : " << addressof(*f) << endl;

	save("소스.cpp");
}



//----------------------------------------------------------<새로운 저장>-------------------------------------------------------
파일 이름 : 소스.cpp
파일크기:913
2022-03-24 14:17:10 GMT+9

//------------------------------------<금일 강의 목표>----------------------------------
// 2022년 1학기 STL	3.24	수910목56 (4주 1일)
// 
// 호출가능타입(Callable type) - sort를 통해 알아본다
// 자원을 확보하는 관찰용 클래스 STRING - 컨테이너/반복자/알고리즘
// contiguous memory는 붙어있기 때문에 []를 쓸수 있고 접는하는데 시간복잡도는 O(1)이다.
// 
//--------------------------------------------------------------------------------------

#include <iostream>
#include <thread>
#include "save.h"

using namespace std;	// 이걸 안써야 하겠다.

// [문제] 호출가능(Callable) 타입(type)
// 1. 함수 포인터 - CODE에서 해당 함수의 시작번지를 저장		//주의! "함수"라고 하면 안됨!!
// 2. 람다(lambda)

//---------------------------
int main()
//---------------------------
{
	[]() {
		cout << "반가워요! 난 람다라고 해!" << endl;
	}();	// ()를 붙여서 호출을 할 수 있다.

	save("소스.cpp");
}



//----------------------------------------------------------<새로운 저장>-------------------------------------------------------
파일 이름 : 소스.cpp
파일크기:964
2022-03-24 14:19:28 GMT+9

//------------------------------------<금일 강의 목표>----------------------------------
// 2022년 1학기 STL	3.24	수910목56 (4주 1일)
// 
// 호출가능타입(Callable type) - sort를 통해 알아본다
// 자원을 확보하는 관찰용 클래스 STRING - 컨테이너/반복자/알고리즘
// contiguous memory는 붙어있기 때문에 []를 쓸수 있고 접는하는데 시간복잡도는 O(1)이다.
// 
//--------------------------------------------------------------------------------------

#include <iostream>
#include <thread>
#include "save.h"

using namespace std;	// 이걸 안써야 하겠다.

// [문제] 호출가능(Callable) 타입(type)
// 1. 함수 포인터 - CODE에서 해당 함수의 시작번지를 저장		//주의! "함수"라고 하면 안됨!!
// 2. 람다(lambda)

//---------------------------
int main()
//---------------------------
{
	cout << typeid(
			//괄호 안쪽이 객체이다.
			[]() {
				cout << "반가워요! 난 람다라고 해!" << endl;
			}
			//여기까지
		).name() << endl;

	save("소스.cpp");
}



//----------------------------------------------------------<새로운 저장>-------------------------------------------------------
파일 이름 : 소스.cpp
파일크기:1072
2022-03-24 14:23:19 GMT+9

//------------------------------------<금일 강의 목표>----------------------------------
// 2022년 1학기 STL	3.24	수910목56 (4주 1일)
// 
// 호출가능타입(Callable type) - sort를 통해 알아본다
// 자원을 확보하는 관찰용 클래스 STRING - 컨테이너/반복자/알고리즘
// contiguous memory는 붙어있기 때문에 []를 쓸수 있고 접는하는데 시간복잡도는 O(1)이다.
// 
//--------------------------------------------------------------------------------------

#include <iostream>
#include <thread>
#include "save.h"

using namespace std;	// 이걸 안써야 하겠다.

// [문제] 호출가능(Callable) 타입(type)
// 1. 함수 포인터 - CODE에서 해당 함수의 시작번지를 저장		//주의! "함수"라고 하면 안됨!!
// 2. 람다(lambda)

//---------------------------
int main()
//---------------------------
{
	auto x = []() {
		cout << "반가워요! 난 람다라고 해!" << endl;
	};

	cout << typeid(x).name() << endl;
	//class `int __cdecl main(void)'::`2'::<lambda_1>
	// 메인에서 만들어진 람다 라는 클래스

	class Dog {};
	cout << typeid(Dog).name() << endl;

	save("소스.cpp");
}



//----------------------------------------------------------<새로운 저장>-------------------------------------------------------
파일 이름 : 소스.cpp
파일크기:1212
2022-03-24 14:25:22 GMT+9

//------------------------------------<금일 강의 목표>----------------------------------
// 2022년 1학기 STL	3.24	수910목56 (4주 1일)
// 
// 호출가능타입(Callable type) - sort를 통해 알아본다
// 자원을 확보하는 관찰용 클래스 STRING - 컨테이너/반복자/알고리즘
// contiguous memory는 붙어있기 때문에 []를 쓸수 있고 접는하는데 시간복잡도는 O(1)이다.
// 
//--------------------------------------------------------------------------------------

#include <iostream>
#include <thread>
#include "save.h"

using namespace std;	// 이걸 안써야 하겠다.

// [문제] 호출가능(Callable) 타입(type)
// 1. 함수 포인터 - CODE에서 해당 함수의 시작번지를 저장		//주의! "함수"라고 하면 안됨!!
// 2. 람다(lambda) - 컴파일러가 만드는 class 이다. (? class가 호출가능?)
// 3. 

auto y = []() {
	cout << "반가워요! 난 람다라고 해!" << endl;
};

//---------------------------
int main()
//---------------------------
{
	auto x = []() {
		cout << "반가워요! 난 람다라고 해!" << endl;
	};

	cout << typeid(x).name() << endl;
	//class `int __cdecl main(void)'::`2'::<lambda_1>
	// 메인에서 만들어진 람다 라는 클래스

	
	cout << typeid(y).name() << endl;
	//전역에서 만들어짐

	save("소스.cpp");
}



//----------------------------------------------------------<새로운 저장>-------------------------------------------------------
파일 이름 : 소스.cpp
파일크기:1160
2022-03-24 14:39:52 GMT+9

//------------------------------------<금일 강의 목표>----------------------------------
// 2022년 1학기 STL	3.24	수910목56 (4주 1일)
// 
// 호출가능타입(Callable type) - sort를 통해 알아본다
// 자원을 확보하는 관찰용 클래스 STRING - 컨테이너/반복자/알고리즘
// contiguous memory는 붙어있기 때문에 []를 쓸수 있고 접는하는데 시간복잡도는 O(1)이다.
// 
//--------------------------------------------------------------------------------------

#include <iostream>
#include <array>
#include <algorithm>
#include "save.h"

using namespace std;	// 이걸 안써야 하겠다.

// [문제] 호출가능(Callable) 타입(type)
// 1. 함수 포인터 - CODE에서 해당 함수의 시작번지를 저장		//주의! "함수"라고 하면 안됨!!
// 2. 람다(lambda) - 컴파일러가 만드는 class 이다. (? class가 호출가능?)
// 3. ()을 오버로딩한 class;

/*
sort(Iter b, Iter e, Callable c){
	.....
	c();
	.....
}
*/

//---------------------------
int main()
//---------------------------
{
	//람다는 어디서 어떻게 사용되나?
	array<int, 5> a{ 3,1,5,2,4 };
	sort(a.begin(), a.end(), [](int a, int b) {
		return a > b; 
		});

	for (int n : a) {
		cout << n << " ";
	}

	save("소스.cpp");
}



//----------------------------------------------------------<새로운 저장>-------------------------------------------------------
파일 이름 : 소스.cpp
파일크기:1163
2022-03-24 14:41:04 GMT+9

//------------------------------------<금일 강의 목표>----------------------------------
// 2022년 1학기 STL	3.24	수910목56 (4주 1일)
// 
// 호출가능타입(Callable type) - sort를 통해 알아본다
// 자원을 확보하는 관찰용 클래스 STRING - 컨테이너/반복자/알고리즘
// contiguous memory는 붙어있기 때문에 []를 쓸수 있고 접는하는데 시간복잡도는 O(1)이다.
// 
//--------------------------------------------------------------------------------------

#include <iostream>
#include <array>
#include <algorithm>
#include "save.h"

using namespace std;	// 이걸 안써야 하겠다.

// [문제] 호출가능(Callable) 타입(type)
// 1. 함수 포인터 - CODE에서 해당 함수의 시작번지를 저장		//주의! "함수"라고 하면 안됨!!
// 2. 람다(lambda) - 컴파일러가 만드는 class 이다. (? class가 호출가능?)
// 3. ()을 오버로딩한 class;

//---------------------------
int main()
//---------------------------
{
	//람다는 어디서 어떻게 사용되나?
	array<int, 5> a{ 3,1,5,2,4 };
	sort(a.begin(), a.end(), [](int a, int b) {
		cout << "람다를 이용해서 " << a << " - " << b << endl;
		return a > b; 
		});

	for (int n : a) {
		cout << n << " ";
	}

	save("소스.cpp");
}



//----------------------------------------------------------<새로운 저장>-------------------------------------------------------
파일 이름 : 소스.cpp
파일크기:1137
2022-03-24 14:47:58 GMT+9

//------------------------------------<금일 강의 목표>----------------------------------
// 2022년 1학기 STL	3.24	수910목56 (4주 1일)
// 
// 호출가능타입(Callable type) - sort를 통해 알아본다
// 자원을 확보하는 관찰용 클래스 STRING - 컨테이너/반복자/알고리즘
// contiguous memory는 붙어있기 때문에 []를 쓸수 있고 접는하는데 시간복잡도는 O(1)이다.
// 
//--------------------------------------------------------------------------------------

#include <iostream>
#include <array>
#include <algorithm>
#include "save.h"

using namespace std;	// 이걸 안써야 하겠다.

// [문제] 호출가능(Callable) 타입(type)
// 1. 함수 포인터 - CODE에서 해당 함수의 시작번지를 저장		//주의! "함수"라고 하면 안됨!!
// 2. 람다(lambda) - 컴파일러가 만드는 class 이다. (? class가 호출가능?)
// 3. ()을 오버로딩한 class;

class Dog {
public:
	bool operator()(int a, int b) {
		cout << "멍!";
		return a < b;
	}
};

//---------------------------
int main()
//---------------------------
{

	array<int, 5> a{ 5,4,3,2,1 };
	sort(a.begin(), a.end(), Dog{});

	for (int n : a) {
		cout << n << " ";
	}

	save("소스.cpp");
}



//----------------------------------------------------------<새로운 저장>-------------------------------------------------------
파일 이름 : 소스.cpp
파일크기:1164
2022-03-24 14:52:06 GMT+9

//------------------------------------<금일 강의 목표>----------------------------------
// 2022년 1학기 STL	3.24	수910목56 (4주 1일)
// 
// 호출가능타입(Callable type) - sort를 통해 알아본다
// 자원을 확보하는 관찰용 클래스 STRING - 컨테이너/반복자/알고리즘
// contiguous memory는 붙어있기 때문에 []를 쓸수 있고 접는하는데 시간복잡도는 O(1)이다.
// 
//--------------------------------------------------------------------------------------

#include <iostream>
#include <array>
#include <algorithm>
#include "save.h"

using namespace std;	// 이걸 안써야 하겠다.

// [문제] 호출가능(Callable) 타입(type)
// 1. 함수 포인터 - CODE에서 해당 함수의 시작번지를 저장		//주의! "함수"라고 하면 안됨!!
// 2. 람다(lambda) - 컴파일러가 만드는 class 이다. (? class가 호출가능?)
// 3. ()을 오버로딩한 class;
// 4, 멤버함수 포인터
//

class Dog {
public:
	bool operator()(int a, int b) {
		cout << "멍!";
		return a < b;
	}
};

//---------------------------
int main()
//---------------------------
{
	auto a = []() {};
	auto b = []() {};
	//a = b // 오류가 난다. 즉, 람다는 서로 다른 클래스이다. => 무한개의 타입

	save("소스.cpp");
}



//----------------------------------------------------------<새로운 저장>-------------------------------------------------------
파일 이름 : 소스.cpp
파일크기:1145
2022-03-24 14:55:14 GMT+9

//------------------------------------<금일 강의 목표>----------------------------------
// 2022년 1학기 STL	3.24	수910목56 (4주 1일)
// 
// 호출가능타입(Callable type) - sort를 통해 알아본다
// 자원을 확보하는 관찰용 클래스 STRING - 컨테이너/반복자/알고리즘
// contiguous memory는 붙어있기 때문에 []를 쓸수 있고 접는하는데 시간복잡도는 O(1)이다.
// 
//--------------------------------------------------------------------------------------

#include <iostream>
#include <functional>
#include "save.h"

using namespace std;	// 이걸 안써야 하겠다.

// [문제] 호출가능(Callable) 타입(type)
// 1. 함수 포인터 - CODE에서 해당 함수의 시작번지를 저장		//주의! "함수"라고 하면 안됨!!
// 2. 람다(lambda) - 컴파일러가 만드는 class 이다. (? class가 호출가능?)
// 3. ()을 오버로딩한 class;
// 4, 멤버함수 포인터
// 
// 호출가능한 타입은 무한개 이다.
// --> 모든 호출가능타입을 통일된 방식으로 표현할 수 있는 클래스 fuction
//

//---------------------------
int main()
//---------------------------
{
	function<int()> f = main;	// function을 이용해 통일된 타입을 사용한다.
	//f();	//메인이 호출된다.

	save("소스.cpp");
}



//----------------------------------------------------------<새로운 저장>-------------------------------------------------------
파일 이름 : 소스.cpp
파일크기:1416
2022-03-24 15:21:50 GMT+9

//------------------------------------<금일 강의 목표>----------------------------------
// 2022년 1학기 STL	3.24	수910목56 (4주 1일)
// 
// 자원을 확보하는 관찰용 클래스 STRING - 컨테이너/반복자/알고리즘
//--------------------------------------------------------------------------------------

#include <iostream>
#include <memory>
#include "save.h"

using namespace std;

// 앞으로 사용할 class STRING 작성 시작(RAII)
// [문제] main이 문제없이 실행도게 하자
// 관찰할 수 있도록 special 함수에 출력메시지를 추가한다.
// 객체가 생성될때마다 고유번호를 준다.

class STRING {
	int num;
	char* p;
	int id;
	static int gid;	//static은 객체의 메모리와 상관없으므로 밖에서 초기화

public:
	STRING(const char* s) : num{ (int)strlen(s) }, p{ new char[num] } {
		id = ++gid;
		memcpy(p, s, num);	//memcpy는 고속DMA 를 수행
		// 관찰메시티 on
		cout << "ctor [ "<< id <<" ] 주소:" << this << endl;
	}

	~STRING() {
		// 관찰메시티 on
		cout << "dtor [ " << id << " ] 주소:" << this << endl;
		delete[] p;
	}

	friend ostream& operator<<(ostream& ,const STRING&);

};

int STRING::gid{};

ostream& operator<<(ostream& os, const STRING& s) {
	os << s.p;
	return os;
}

//---------------------------
int main()
//---------------------------
{
	STRING a{ "2022 3 24" };
	STRING b{ "STL STRING 작성 시작" };

	cout << a << endl;
	cout << b << endl;
	save("소스.cpp");
}



//----------------------------------------------------------<새로운 저장>-------------------------------------------------------
파일 이름 : 소스.cpp
파일크기:1568
2022-03-30 17:38:05 GMT+9

//------------------------------------<금일 강의 목표>----------------------------------
// 2022년 1학기 STL	3.30	수910목56 (4주 2일)
// 
// 자원을 확보하는 관찰용 클래스 STRING - 컨테이너/반복자/알고리즘
//--------------------------------------------------------------------------------------

#include <iostream>
#include <memory>
#include "save.h"

using namespace std;

// 앞으로 사용할 class STRING 작성 시작(RAII)
// [문제] main이 문제없이 실행도게 하자
// 관찰할 수 있도록 special 함수에 출력메시지를 추가한다.
// 객체가 생성될때마다 고유번호를 준다.

class STRING {
	int num;
	int id;
	char* p;	// 메모리가 8바이트 단위로 할당해서 4(8)/8/4(8) 바이트 순으로 할경우 24바이트 할당됨(패딩!!). release에서 그러하다.
	static int gid;	//static은 객체의 메모리와 상관없으므로 밖에서 초기화

public:
	STRING(const char* s) : num{ (int)strlen(s) }, p{ new char[num] } {
		id = ++gid;
		memcpy(p, s, num);	//memcpy는 고속DMA 를 수행
		// 관찰메시티 on
		cout << "ctor [ "<< id <<" ] 주소:" << this << endl;
	}

	~STRING() {
		// 관찰메시티 on
		cout << "dtor [ " << id << " ] 주소:" << this << endl;
		delete[] p;
	}

	friend ostream& operator<<(ostream& ,const STRING&);

};

int STRING::gid{};

ostream& operator<<(ostream& os, const STRING& s) {
	os << s.p;
	return os;
}

//---------------------------
int main()
//---------------------------
{
	cout << sizeof(STRING) << endl;

	STRING a{ "2022 3 24" };
	STRING b{ "STL STRING 작성 시작" };

	cout << a << endl;
	cout << b << endl;
	save("소스.cpp");
}



//----------------------------------------------------------<새로운 저장>-------------------------------------------------------
파일 이름 : 소스.cpp
파일크기:2037
2022-03-30 17:52:46 GMT+9

//------------------------------------<금일 강의 목표>----------------------------------
// 2022년 1학기 STL	3.30	수910목56 (4주 2일)
// 
// 자원을 확보하는 관찰용 클래스 STRING - 컨테이너/반복자/알고리즘
//--------------------------------------------------------------------------------------

#include <iostream>
#include <memory>
#include "save.h"

using namespace std;

// 앞으로 사용할 class STRING 작성 시작(RAII)
// [문제] main이 문제없이 실행도게 하자
// 관찰할 수 있도록 special 함수에 출력메시지를 추가한다.
// 객체가 생성될때마다 고유번호를 준다.

//개선할것
bool 관찰{ false };

class STRING {
	size_t num;
	int id;
	char* p;	// 메모리가 8바이트 단위로 할당해서 4(8)/8/4(8) 바이트 순으로 할경우 24바이트 할당됨(패딩!!). release에서 그러하다.
	static int gid;	//static은 객체의 메모리와 상관없으므로 밖에서 초기화

public:
	//,로 엮은 변ㄴ수를 할당할때 순서가 보장되지 않아서 p를 따로 할당한다.
	STRING(const char* s) : num{ strlen(s) } {		//축소변환 : 메모리크기가 작아지면서 데이터가 작아직수 있으므로 size_t를 사용
		p = new char[num];
		id = ++gid;
		memcpy(p, s, num);	//memcpy는 고속DMA 를 수행

		if (관찰)
			print("생성자(*)");

		// 관찰메시티 on
	}

	~STRING() {
		// 관찰메시티 on
		if (관찰) {
			print("소멸자");
		}
		if (num) {
			delete[] p;
		}
	}

	void print(const char* s) const {
		cout << s << " [" << id << "] 객체:" << this;
		if (num) {
			cout << " - 자원 : " << num << " 주소 : " << (void*)p;	// 캐릭터 포인터는고수준 입출력이라 문자열이 입력된다.
		}
		else {
			cout << " - 자원없음";
		}
		cout << endl;
	}


	friend ostream& operator<<(ostream& ,const STRING&);

};

int STRING::gid{};

ostream& operator<<(ostream& os, const STRING& s)
{
	for (int i{}; i < s.num; ++i) {
		os << s.p[i];
	}
	return os;
}

//---------------------------
int main()
//---------------------------
{

	STRING a{ "2022 3 24" };
	STRING b{ "STL STRING 작성 시작" };

	cout << a << endl;
	cout << b << endl;
	save("소스.cpp");
}



//----------------------------------------------------------<새로운 저장>-------------------------------------------------------
파일 이름 : 소스.cpp
파일크기:2936
2022-03-30 18:37:59 GMT+9

//------------------------------------<금일 강의 목표>----------------------------------
// 2022년 1학기 STL	3.30	수910목56 (4주 2일)
// 
// 자원을 확보하는 관찰용 클래스 STRING - 컨테이너/반복자/알고리즘
// 
// 컴파일러 최적화 - RVO(리턴시 복사생성x), copy ellision
//				   
//--------------------------------------------------------------------------------------

#include <iostream>
#include <memory>
#include "save.h"

using namespace std;

// 앞으로 사용할 class STRING 작성 시작(RAII)
// [문제] main이 문제없이 실행도게 하자
// 관찰할 수 있도록 special 함수에 출력메시지를 추가한다.
// 객체가 생성될때마다 고유번호를 준다.

//개선할것
bool 관찰{ false };

class STRING {
	size_t num;									//관리하는 자원수
	int id;										//생성 시 부여한 고유값									
	char* p;									//자원의 주소	// 메모리가 8바이트 단위로 할당해서 4(8)/8/4(8) 바이트 순으로 할경우 24바이트 할당됨(패딩!!). release에서 그러하다.
	static int gid;								//아이디 생성용	//static은 객체의 메모리와 상관없으므로 밖에서 초기화

public:
	STRING() : num{}, p{}, id{ ++gid } {
		if (관찰)
			print("디폴트");

	}

	//,로 엮은 변수를 할당할때 순서가 보장되지 않아서 p를 따로 할당한다.
	STRING(const char* s) : num{ strlen(s) } {		//축소변환 : 메모리크기가 작아지면서 데이터가 작아직수 있으므로 size_t를 사용
		p = new char[num];
		id = ++gid;
		memcpy(p, s, num);	//memcpy는 고속DMA 를 수행

		if (관찰)
			print("생성자(*)");

		// 관찰메시티 on
	}

	~STRING() {
		// 관찰메시티 on
		if (관찰) {
			print("소멸자");
		}
		if (num) {
			delete[] p;
		}
	}

	STRING(const STRING& other) : id{ ++gid }, num{ other.num }{
		p = new char[num];
		memcpy(p, other.p, num);
		if (관찰)
			print("복사생성");
	}

	STRING& operator=(const STRING& other) {
		if (this == &other)
			return *this;

		if (num)
			delete[] p;

		num = other.num;
		p = new char[num];
		memcpy(p, other.p, num);

		if (관찰)
			print("복사할당");

	}

	STRING operator+(const STRING& rhs) const {
		STRING temp;	//임시객체를 만들어 더한후 리턴
		temp.num = num + rhs.num;
		temp.p = new char[temp.num];

		memcpy(temp.p, p, num);
		memcpy(temp.p + num, rhs.p, rhs.num);
		return temp;
	}

	void print(const char* s) const {
		cout << s << " [" << id << "] 객체:" << this;
		if (num) {
			cout << " - 자원 : " << num << " 주소 : " << (void*)p;	// 캐릭터 포인터는고수준 입출력이라 문자열이 입력된다.
		}
		else {
			cout << " - 자원없음";
		}
		cout << endl;
	}

	friend ostream& operator<<(ostream& ,const STRING&);

};

int STRING::gid{};

ostream& operator<<(ostream& os, const STRING& s)
{
	for (int i{}; i < s.num; ++i) {
		os << s.p[i];
	}
	return os;
}

//---------------------------
int main()
//---------------------------
{
	관찰 = true;
	STRING a{ "2022년 " };
	STRING b{ "3월 30일" };
	STRING c = a + b;

	cout << c << endl;

	save("소스.cpp");
}



//----------------------------------------------------------<새로운 저장>-------------------------------------------------------
파일 이름 : 소스.cpp
파일크기:511
2022-03-30 18:51:24 GMT+9

//------------------------------------<금일 강의 목표>----------------------------------
// 2022년 1학기 STL	3.30	수910목56 (4주 2일)
// 
//	STRING 클래스 파일 분리			   
//--------------------------------------------------------------------------------------

#include <iostream>
#include "save.h"
#include "STRING.h"
using namespace std;


//---------------------------
int main()
//---------------------------
{
	cout << STRING{ "123" } + STRING{ "4,5,6" } << endl;
	save("소스.cpp");
}



//----------------------------------------------------------<새로운 저장>-------------------------------------------------------
파일 이름 : 소스.cpp
파일크기:553
2022-03-30 18:51:51 GMT+9

//------------------------------------<금일 강의 목표>----------------------------------
// 2022년 1학기 STL	3.30	수910목56 (4주 2일)
// 
//	STRING 클래스 파일 분리			   
//--------------------------------------------------------------------------------------

#include <iostream>
#include "save.h"
#include "STRING.h"
using namespace std;


//---------------------------
int main()
//---------------------------
{
	cout << STRING{ "123" } + STRING{ "4,5,6" } << endl;
	save("소스.cpp");
	save("STRING.h");
	save("STRING.cpp");
}



//----------------------------------------------------------<새로운 저장>-------------------------------------------------------
파일 이름 : STRING.h
파일크기:1011
2022-03-30 18:51:51 GMT+9

//-----------------------------------------------------------------------------
//STRING - STL 내부 동작을 관찰하려고 만든 자원을 관리하는 클래스
//		 - std::string 동작 대부분을 직접 구현하며 STL 동작방식을 이해
// 
// 2022.3.30							
//-----------------------------------------------------------------------------

#pragma once

#include <iostream>

class STRING {
	size_t num;									//관리하는 자원소
	int id;										//생성 시 부여한 고유값									
	char* p;									//자원의 주소	// 메모리가 8바이트 단위로 할당해서 4(8)/8/4(8) 바이트 순으로 할경우 24바이트 할당됨(패딩!!). release에서 그러하다.
	static int gid;								//아이디 생성용	//static은 객체의 메모리와 상관없으므로 밖에서 초기화

public:
	STRING();
	STRING(const char* s);
	~STRING();

	STRING(const STRING& other);
	STRING& operator=(const STRING& other);

	STRING operator+(const STRING& rhs) const;

	void print(const char* s) const;

	friend std::ostream& operator<<(std::ostream&, const STRING&);
};




//----------------------------------------------------------<새로운 저장>-------------------------------------------------------
파일 이름 : STRING.cpp
파일크기:2090
2022-03-30 18:51:51 GMT+9

//-----------------------------------------------------------------------------
//STRING - STL 내부 동작을 관찰하려고 만든 자원을 관리하는 클래스
//		 - std::string 동작 대부분을 직접 구현하며 STL 동작방식을 이해
// 
// 2022.3.30							
//-----------------------------------------------------------------------------

#include<iostream>
#include "STRING.h"

bool 관찰{ false };						// 관찰메시지 보려면 True
int STRING::gid{};						// class static 

STRING::STRING() : num{}, p{}, id{ ++gid }
{
	if (관찰)
		print("디폴트");
}

//,로 엮은 변수를 할당할때 순서가 보장되지 않아서 p를 따로 할당한다.
STRING::STRING(const char* s) : num{ strlen(s) }
{		//축소변환 : 메모리크기가 작아지면서 데이터가 작아직수 있으므로 size_t를 사용
	p = new char[num];
	id = ++gid;
	memcpy(p, s, num);	//memcpy는 고속DMA 를 수행

	if (관찰)
		print("생성자(*)");

	// 관찰메시티 on
}

STRING::~STRING() 
{
	// 관찰메시티 on
	if (관찰) {
		print("소멸자");
	}
	if (num) {
		delete[] p;
	}
}

STRING::STRING(const STRING& other) : id{ ++gid }, num{ other.num }
{
	p = new char[num];
	memcpy(p, other.p, num);
	if (관찰)
		print("복사생성");
}

STRING& STRING::operator=(const STRING& other)
{
	if (this == &other)
		return *this;

	if (num)
		delete[] p;

	num = other.num;
	p = new char[num];
	memcpy(p, other.p, num);

	if (관찰)
		print("복사할당");

}

STRING STRING::operator+(const STRING& rhs) const
{
	STRING temp;	//임시객체를 만들어 더한후 리턴
	temp.num = num + rhs.num;
	temp.p = new char[temp.num];

	memcpy(temp.p, p, num);
	memcpy(temp.p + num, rhs.p, rhs.num);
	return temp;
}

void STRING::print(const char* s) const
{
	std::cout << s << " [" << id << "] 객체:" << this;
	if (num) {
		std::cout << " - 자원 : " << num << " 주소 : " << (void*)p;	// 캐릭터 포인터는고수준 입출력이라 문자열이 입력된다.
	}
	else {
		std::cout << " - 자원없음";
	}
	std::cout << std::endl;
}

std::ostream& operator<<(std::ostream& os, const STRING& s)
{
	for (int i{}; i < s.num; ++i) {
		os << s.p[i];
	}
	return os;
}

//----------------------------------------------------------<새로운 저장>-------------------------------------------------------
파일 이름 : 소스.cpp
파일크기:642
2022-03-31 13:36:30 GMT+9

//------------------------------------<금일 강의 목표>----------------------------------
// 2022년 1학기 STL	3.31	수910목56 (5주 1일)
// 
//  컨테이너는 다른 객체를 담는 객체
//--------------------------------------------------------------------------------------

#include <iostream>
#include <array>
#include "save.h"
#include "STRING.h"
using namespace std;

template<class T, int N>
class Array {
	T data[N];

public:
	Array() {

	}

	size_t size() {
		return N;
	}

};

//---------------------------
int main()
//---------------------------
{
	Array<int, 10> a;
	
	cout << "Array<>의 크기 - " << sizeof(a) << endl;

	cout << "원소 갯수 - " << a.size() << endl;

	save("소스.cpp");
}



//----------------------------------------------------------<새로운 저장>-------------------------------------------------------
파일 이름 : 소스.cpp
파일크기:883
2022-03-31 14:19:40 GMT+9

//------------------------------------<금일 강의 목표>----------------------------------
// 2022년 1학기 STL	3.31	수910목56 (5주 1일)
// 
//  컨테이너는 다른 객체를 담는 객체
// 
// https://en.cppreference.com/w/cpp/named_req/Container -> 컨테이너가 되기 위한 조건
// 
// STL
// - 자료구조(Container) + 알고리즘
// 반복
// - 덱은 연속된 자료가 포인터로 연결되어 있다.(vector+list같은 느낌)
// 
//--------------------------------------------------------------------------------------

#include <iostream>
#include <array>
#include "save.h"
#include "STRING.h"
using namespace std;

//---------------------------
int main()
//---------------------------
{
	//자료구조
	array<int, 10> a{ 1, 3, 5, 7, 9, 2, 4, 6, 8, 10 };

	for (array<int, 10>::iterator i = a.begin(); i != a.end(); ++i) {
		cout << *i << ' ';
	}
	cout << endl;

	save("소스.cpp");
}



//----------------------------------------------------------<새로운 저장>-------------------------------------------------------
파일 이름 : 소스.cpp
파일크기:931
2022-03-31 14:22:09 GMT+9

//------------------------------------<금일 강의 목표>----------------------------------
// 2022년 1학기 STL	3.31	수910목56 (5주 1일)
// 
//  컨테이너는 다른 객체를 담는 객체
// 
// https://en.cppreference.com/w/cpp/named_req/Container -> 컨테이너가 되기 위한 조건
// 
// STL
// - 자료구조(Container) + 알고리즘
// 반복
// - 덱은 연속된 자료가 포인터로 연결되어 있다.(vector+list같은 느낌)
// 
//--------------------------------------------------------------------------------------

#include <iostream>
#include <array>
#include "save.h"
#include "STRING.h"
using namespace std;

//---------------------------
int main()
//---------------------------
{
	//자료구조
	array<int, 10> a{ 1, 3, 5, 7, 9, 2, 4, 6, 8, 10 };

	for (auto i = a.cbegin(); i != a.cend(); ++i) {	//cbegin() : constBegin 이라는 의미, 즉 값을 바꾸지 않겠다는 의미
		cout << *i << ' ';
	}
	cout << endl;

	save("소스.cpp");
}



//----------------------------------------------------------<새로운 저장>-------------------------------------------------------
파일 이름 : 소스.cpp
파일크기:904
2022-03-31 14:23:33 GMT+9

//------------------------------------<금일 강의 목표>----------------------------------
// 2022년 1학기 STL	3.31	수910목56 (5주 1일)
// 
//  컨테이너는 다른 객체를 담는 객체
// 
// https://en.cppreference.com/w/cpp/named_req/Container -> 컨테이너가 되기 위한 조건
// 
// STL
// - 자료구조(Container) + 알고리즘
// 반복
// - 덱은 연속된 자료가 포인터로 연결되어 있다.(vector+list같은 느낌)
// 
//--------------------------------------------------------------------------------------

#include <iostream>
#include <array>
#include "save.h"
#include "STRING.h"
using namespace std;

//---------------------------
int main()
//---------------------------
{
	//자료구조
	array<int, 10> a{ 1, 3, 5, 7, 9, 2, 4, 6, 8, 10 };

	auto i = a.cbegin();
	while (i != a.cend())	// 반복자를 사용할 때 while루프를 많이쓴다.
		cout << *i++ << " ";
	cout << endl;

	save("소스.cpp");
}



//----------------------------------------------------------<새로운 저장>-------------------------------------------------------
파일 이름 : 소스.cpp
파일크기:866
2022-03-31 14:25:10 GMT+9

//------------------------------------<금일 강의 목표>----------------------------------
// 2022년 1학기 STL	3.31	수910목56 (5주 1일)
// 
//  컨테이너는 다른 객체를 담는 객체
// 
// https://en.cppreference.com/w/cpp/named_req/Container -> 컨테이너가 되기 위한 조건
// 
// STL
// - 자료구조(Container) + 알고리즘
// 반복
// - 덱은 연속된 자료가 포인터로 연결되어 있다.(vector+list같은 느낌)
// 
//--------------------------------------------------------------------------------------

#include <iostream>
#include <array>
#include "save.h"
#include "STRING.h"
using namespace std;

//---------------------------
int main()
//---------------------------
{
	//자료구조
	array<int, 10> a{ 1, 3, 5, 7, 9, 2, 4, 6, 8, 10 };

	for (auto x : a)		// 편리함을 위해 한번더 포장한 문법
		cout << x << " ";
	cout << endl;

	save("소스.cpp");
}



//----------------------------------------------------------<새로운 저장>-------------------------------------------------------
파일 이름 : 소스.cpp
파일크기:868
2022-03-31 14:39:13 GMT+9

//------------------------------------<금일 강의 목표>----------------------------------
// 2022년 1학기 STL	3.31	수910목56 (5주 1일)
// 
//  컨테이너는 다른 객체를 담는 객체
// 
// https://en.cppreference.com/w/cpp/named_req/Container -> 컨테이너가 되기 위한 조건
// 
// STL
// - 자료구조(Container) + 알고리즘
// 반복
// - 덱은 연속된 자료가 포인터로 연결되어 있다.(vector+list같은 느낌)
// 
//--------------------------------------------------------------------------------------

#include <iostream>
#include <array>
#include "save.h"
#include "STRING.h"
using namespace std;

//---------------------------
int main()
//---------------------------
{



	//자료구조
	array<int, 10> a{ 1, 3, 5, 7, 9, 2, 4, 6, 8, 10 };

	for (auto i = a.crbegin(); i != a.crend(); ++i) {
		cout << *i << " ";
	} 
	cout << "\n";

	save("소스.cpp");
}



//----------------------------------------------------------<새로운 저장>-------------------------------------------------------
파일 이름 : 소스.cpp
파일크기:976
2022-03-31 14:52:49 GMT+9

//------------------------------------<금일 강의 목표>----------------------------------
// 2022년 1학기 STL	3.31	수910목56 (5주 1일)
// 
//  컨테이너는 다른 객체를 담는 객체
// 
// https://en.cppreference.com/w/cpp/named_req/Container -> 컨테이너가 되기 위한 조건
// 
// STL
// - 자료구조(Container) + 알고리즘
// 반복
// - 덱은 연속된 자료가 포인터로 연결되어 있다.(vector+list같은 느낌)
// 
//--------------------------------------------------------------------------------------

#include <iostream>
#include <array>
#include "save.h"
#include "STRING.h"
using namespace std;

//---------------------------
int main()
//---------------------------
{
	array<int, 5> a{2, 4, 6, 8, 10};

	save("소스.cpp");

	while (true) {
		cout << "몇 번째인지 알려주세요: ";
		int num;
		cin >> num;

		try {
			cout << num << "번째 값은 - " << a.at(num) << endl;	//범위를 벗어나면 바로 예외를 던진다.
		}
		catch (exception& e) {
			cout << "유효범위는 0-4" << endl;
		}
		

	}
}



//----------------------------------------------------------<새로운 저장>-------------------------------------------------------
파일 이름 : 소스.cpp
파일크기:1041
2022-03-31 15:07:46 GMT+9

//------------------------------------<금일 강의 목표>----------------------------------
// 2022년 1학기 STL	3.31	수910목56 (5주 1일)
// 
//  컨테이너는 다른 객체를 담는 객체
// 
// 1. Sequence container
//			array			- 유일하게 크기가 고정, [] 대체
//			vector			- 
//			deque
//			forward_list
//			list
// 
//--------------------------------------------------------------------------------------

#include <iostream>
#include <vector>
#include <fstream>
#include "save.h"
#include "STRING.h"
using namespace std;

// [문제] "소스.cpp"를 공백까지 vector에 저장하라
// 화면에 vector의 char를 모두 출력하라
//

//---------------------------
int main()
//---------------------------
{
	ifstream in{ "소스.cpp" };
	vector<char> v;

	in >> noskipws;

	char ch;
	while (in >> ch) {
		v.push_back(ch);
	}

	for (char c : v) {
		cout << c;
	}

	//vector<char> v{ istreambuf_iterator<char>{in}, {} };

	//for (auto i = v.cbegin(); i != v.cend(); ++i) {
	//	cout << *i;
	//}

	save("소스.cpp");
}



//----------------------------------------------------------<새로운 저장>-------------------------------------------------------
파일 이름 : 소스.cpp
파일크기:965
2022-03-31 15:21:32 GMT+9

//------------------------------------<금일 강의 목표>----------------------------------
// 2022년 1학기 STL	3.31	수910목56 (5주 1일)
// 
//  컨테이너는 다른 객체를 담는 객체
// 
// 1. Sequence container
//			array			- 유일하게 크기가 고정, [] 대체
//			vector			- 
//			deque
//			forward_list
//			list
// 
//--------------------------------------------------------------------------------------

#include <iostream>
#include <vector>
#include <string>
#include <algorithm>
#include "save.h"
#include "STRING.h"
using namespace std;

// [문제] 단어(string)를 키보드(cin)에서 입력받아 
// 오름차순 정렬한 후
// 화면에 출력하라
//

//---------------------------
int main()
//---------------------------
{
	vector<string> v;

	string s;
	while (cin >> s) {
		v.push_back(s);
	}

	sort(v.begin(), v.end());				// 5주 2일 과제 설명 내림차순

	for (const string& str : v) {
		cout << str << " ";
	}

	save("소스.cpp");
}



//----------------------------------------------------------<새로운 저장>-------------------------------------------------------
파일 이름 : 소스.cpp
파일크기:1010
2022-03-31 15:24:16 GMT+9

//------------------------------------<금일 강의 목표>----------------------------------
// 2022년 1학기 STL	3.31	수910목56 (5주 1일)
// 
//  컨테이너는 다른 객체를 담는 객체
// 
// 1. Sequence container
//			array			- 유일하게 크기가 고정, [] 대체
//			vector			- 
//			deque
//			forward_list
//			list
// 
//--------------------------------------------------------------------------------------

#include <iostream>
#include <vector>
#include <string>
#include <algorithm>
#include "save.h"
#include "STRING.h"
using namespace std;

// [문제] 단어(string)를 키보드(cin)에서 입력받아 
// 오름차순 정렬한 후
// 화면에 출력하라
//

//---------------------------
int main()
//---------------------------
{
	vector<string> v{ istream_iterator<string>{cin}, {} };

	//string s;
	//while (cin >> s) {
	//	v.push_back(s);
	//}

	sort(v.begin(), v.end());				// 5주 2일 과제 설명 내림차순

	for (const string& str : v) {
		cout << str << " ";
	}

	save("소스.cpp");
}



//----------------------------------------------------------<새로운 저장>-------------------------------------------------------
파일 이름 : 소스.cpp
파일크기:721
2022-04-06 18:06:48 GMT+9

//------------------------------------<금일 강의 목표>----------------------------------
// 2022년 1학기 STL	4.06	수910목56 (5주 2일)
// 
//--------------------------------------------------------------------------------------

#include <iostream>
#include <vector>
#include <numeric>
#include "save.h"
#include "STRING.h"
using namespace std;

// [문제] 키보드에서 int를 그만 할때까지 입력받아라.
// 함계와 평균을 화면 출력하라
//

//---------------------------
int main()
//---------------------------
{

	vector v{ istream_iterator<int>{cin}, {} };
	long long int sum{ accumulate(v.begin(), v.end(), 0) };
	cout << "합계:" << sum << ", 평균" << sum / v.size() << endl;

	save("소스.cpp");
}



//----------------------------------------------------------<새로운 저장>-------------------------------------------------------
파일 이름 : 소스.cpp
파일크기:1230
2022-04-06 18:17:25 GMT+9

//------------------------------------<금일 강의 목표>----------------------------------
// 2022년 1학기 STL	4.06	수910목56 (5주 2일)
// 
//--------------------------------------------------------------------------------------

#include <iostream>
#include <vector>
#include <numeric>
#include "save.h"
#include "STRING.h"
using namespace std;

// [문제] 키보드에서 int를 그만 할때까지 입력받아라.
// 함계와 평균을 화면 출력하라
//

//---------------------------
int main()
//---------------------------
{
	vector<int> v;



	int num;
	while (cin >> num) {
		v.push_back(num);
	}

	long long sum{};
	// 래퍼런스를 쓰는 이유 : 원본에 직접접근, 원본을 복사하는 것이 부담스럽기 때문에
	// 4바이트 int을 읽기 위해 8바이트 포인터를 쓰는건 오히려 손해이다.
	for (const int& num : v) {	// 따라서 이 코드는 "int num : v"으로 바꿔줘야 한다. + const를 붙여쓸 이유가 없다(특별한 이유 없을 경우)
		sum += num;
	}

	cout << "합계 - " << sum << endl;
	cout << "평균 - " << (double)sum/v.size() << endl;

	//vector v{ istream_iterator<int>{cin}, {} };
	//long long int sum{ accumulate(v.begin(), v.end(), 0) };
	//cout << "합계:" << sum << ", 평균" << sum / v.size() << endl;

	save("소스.cpp");
}





//----------------------------------------------------------<새로운 저장>-------------------------------------------------------
파일 이름 : 소스.cpp
파일크기:884
2022-04-06 18:20:37 GMT+9

//------------------------------------<금일 강의 목표>----------------------------------
// 2022년 1학기 STL	4.06	수910목56 (5주 2일)
// 
//--------------------------------------------------------------------------------------

#include <iostream>
#include <vector>
#include <numeric>
#include "save.h"
#include "STRING.h"
using namespace std;

// [문제] 키보드에서 int를 그만 할때까지 입력받아라.
// 함계와 평균을 화면 출력하라
//

//---------------------------
int main()
//---------------------------
{
	vector<int> v;

	cout << "담을 수 있는 최대 int 수 - " << v.max_size() << endl;
	// 4611686018427387903 - int
	//  768614336404564650 - STRING

	save("소스.cpp");
}



//----------------------------------------------------------<새로운 저장>-------------------------------------------------------
파일 이름 : 소스.cpp
파일크기:790
2022-04-06 18:33:34 GMT+9

//------------------------------------<금일 강의 목표>----------------------------------
// 2022년 1학기 STL	4.06	수910목56 (5주 2일)
// 
//--------------------------------------------------------------------------------------

#include <iostream>
#include <vector>
#include <numeric>
#include "save.h"
#include "STRING.h"
using namespace std;

// [문제] 키보드에서 int를 그만 할때까지 입력받아라.
// 함계와 평균을 화면 출력하라
//

//---------------------------
int main()
//---------------------------
{
	vector<int> v{ 1,2,3 };

	cout << "원소 갯수 - " << v.size() << endl;
	cout << "데이터 위치 - " << v.data() << endl;
	cout << "용량 " << v.capacity() << endl;

	//cout << "벡터가 메모리에 차지하는 크기 - " << sizeof(v) << endl;
	
	save("소스.cpp");
}



//----------------------------------------------------------<새로운 저장>-------------------------------------------------------
파일 이름 : 소스.cpp
파일크기:1189
2022-04-06 18:36:35 GMT+9

//------------------------------------<금일 강의 목표>----------------------------------
// 2022년 1학기 STL	4.06	수910목56 (5주 2일)
// 
//--------------------------------------------------------------------------------------

#include <iostream>
#include <vector>
#include <numeric>
#include "save.h"
#include "STRING.h"
using namespace std;

// [문제] 키보드에서 int를 그만 할때까지 입력받아라.
// 함계와 평균을 화면 출력하라
//

//---------------------------
int main()
//---------------------------
{
	//벡터의 메모리가 24인 이유 : 데이터의 개수, 데이터의 위치, 용량
	
	vector<int> v{ 1,2,3,4 };

	cout << "원소 갯수 - " << v.size() << endl;
	cout << "데이터 위치 - " << v.data() << endl;
	cout << "용량 " << v.capacity() << endl;

	v.push_back(5);	//용량이 넘치면서 새로운 공간메 메모리를 할당 받는다.

	cout << endl;
	cout << "원소 갯수 - " << v.size() << endl;
	cout << "데이터 위치 - " << v.data() << endl;
	cout << "용량 " << v.capacity() << endl;

	v.push_back(6);	//용량에 여유 공간이 있기 때문에 메모리를 다시 할당할 필요 없다.

	cout << endl;
	cout << "원소 갯수 - " << v.size() << endl;
	cout << "데이터 위치 - " << v.data() << endl;
	cout << "용량 " << v.capacity() << endl;

	save("소스.cpp");
}



//----------------------------------------------------------<새로운 저장>-------------------------------------------------------
파일 이름 : 소스.cpp
파일크기:924
2022-04-06 18:44:53 GMT+9

//------------------------------------<금일 강의 목표>----------------------------------
// 2022년 1학기 STL	4.06	수910목56 (5주 2일)
// 
//--------------------------------------------------------------------------------------

#include <iostream>
#include <vector>
#include <numeric>
#include "save.h"
#include "STRING.h"
using namespace std;

// [문제] v에 원소를 하나씩 추가하며 메모리가 확장되는 모습을 관찰하라
//

//---------------------------
int main()
//---------------------------
{
	//벡터의 메모리가 24인 이유 : 데이터의 개수, 데이터의 위치, 용량

	vector<int> v;

	size_t old{ v.capacity() };
	while (true){
		v.push_back(1);

		if (old == v.size() - 1) {
			cout << "원소 수 - " << v.size() << endl;
			cout << "용량    - " << v.capacity() << endl;
			old = v.capacity();
			cout << endl;
		}

		if (v.capacity() > 1000000) {
			break;
		}

	}

	save("소스.cpp");
}



//----------------------------------------------------------<새로운 저장>-------------------------------------------------------
파일 이름 : 소스.cpp
파일크기:644
2022-04-06 19:03:39 GMT+9

//------------------------------------<금일 강의 목표>----------------------------------
// 2022년 1학기 STL	4.06	수910목56 (5주 2일)
// 
//--------------------------------------------------------------------------------------

#include <iostream>
#include <vector>
#include "save.h"
#include "STRING.h"
using namespace std;

// [문제] v에 원소를 하나씩 추가하며 메모리가 확장되는 모습을 관찰하라
//

extern bool 관찰;

//---------------------------
int main()
//---------------------------
{
	관찰 = true;

	vector<STRING> v{ "12345" };
	// [1] 은 "12345"
	// [2] 는 vector가 가리키는string

	save("소스.cpp");
}



//----------------------------------------------------------<새로운 저장>-------------------------------------------------------
파일 이름 : 소스.cpp
파일크기:744
2022-04-06 19:09:35 GMT+9

//------------------------------------<금일 강의 목표>----------------------------------
// 2022년 1학기 STL	4.06	수910목56 (5주 2일)
// 
//--------------------------------------------------------------------------------------

#include <iostream>
#include <vector>
#include "save.h"
#include "STRING.h"
using namespace std;

// [문제] v에 원소를 하나씩 추가하며 메모리가 확장되는 모습을 관찰하라
//

extern bool 관찰;

//---------------------------
int main()
//---------------------------
{
	관찰 = true;

	vector<STRING> v{ "12345" };
	v.push_back("1234567");
	// [1] "12345"
	// [2] v의 string
	// [3] "1234567"
	// [4] v의 용량이 부족하므로 [2]을 [4]에 복사
	// [5] [3]을 [5]에 복사

	save("소스.cpp");
}


//----------------------------------------------------------<새로운 저장>-------------------------------------------------------
파일 이름 : 소스.cpp
파일크기:914
2022-04-07 13:56:40 GMT+9

//------------------------------------<금일 강의 목표>----------------------------------
// 2022년 1학기 STL	4.07	수910목56 (6주 1일)
// 
//--------------------------------------------------------------------------------------

#include <iostream>
#include <vector>
#include "save.h"
#include "STRING.h"
using namespace std;

// [문제] v에 원소를 하나씩 추가하며 메모리가 확장되는 모습을 관찰하라
//

extern bool 관찰;

//---------------------------
int main()
//---------------------------
{
	관찰 = true;

	vector<STRING> v;
	v.reserve(10);	//용량을 마련한다.
	v.emplace_back( STRING{ "12345" } );	//이렇게 쓰면 복사생성자가 그대로 생긴다. 쓰면안됨

	//emplace_back : 생성자의 인자만 전달해서 벡터가 직접 빈공간에 생성자를 호출하여 넣는다..(=임식객체를 만들지 않는다.)
	v.emplace_back("1234567");	// v.emplace_back(STRING{"1234567"});이라고 쓰면 안된다.
	

	save("소스.cpp");
}



//----------------------------------------------------------<새로운 저장>-------------------------------------------------------
파일 이름 : 소스.cpp
파일크기:849
2022-04-07 14:19:11 GMT+9

//------------------------------------<금일 강의 목표>----------------------------------
// 2022년 1학기 STL	4.07	수910목56 (6주 1일)
// 
//--------------------------------------------------------------------------------------

#include <iostream>
#include <vector>
#include "save.h"
#include "STRING.h"
using namespace std;

// [문제] v에 원소를 하나씩 추가하며 메모리가 확장되는 모습을 관찰하라
//

extern bool 관찰;

//---------------------------
int main()
//---------------------------
{
	관찰 = true;

	vector<STRING> v;

	v.push_back("1");	// 노네임드 변수는 거리낌없이 할당받은 자원을 뺐어올 수 있지만, 벡터에 있는 변수를 다른쪽으로 이동할때는 (예외처리등으로 위험함으로)안전하게 복사를 해야하므로 .... 완벽하게 복사할때까지 자원을 넘겨주면 안됨
	v.push_back("12");	// 따라서 이동생성을 확실하게 하기 위해서 noexcept(예외를 던지지 않겠다.)를 선언해준다.
	v.push_back("123");

	save("소스.cpp");
}



//----------------------------------------------------------<새로운 저장>-------------------------------------------------------
파일 이름 : 소스.cpp
파일크기:862
2022-04-07 14:37:35 GMT+9

//------------------------------------<금일 강의 목표>----------------------------------
// 2022년 1학기 STL	4.07	수910목56 (6주 1일)
// 
//--------------------------------------------------------------------------------------

#include <iostream>
#include <vector>
#include <algorithm>
#include "save.h"
#include "STRING.h"
using namespace std;

// [문제] v에 원소를 하나씩 추가하며 메모리가 확장되는 모습을 관찰하라
//

extern bool 관찰;

//---------------------------
int main()
//---------------------------
{
	

	vector<STRING> v{ "1", "333", "22", "55555", "4444" };

	// [문제] 길이 오름차순 정렬
	// 자원을 할당하는 클래스일 경우 이동할당/이동생성을 구현해 놔야 속도가 빨라진다!!!!!

	관찰 = true;
	sort(v.begin(), v.end(), [](const STRING& a, const STRING& b) {
		return a.getNum() < b.getNum();
		});
	관찰 = false;

	for (int i = 0; i < v.size(); ++i)
		cout << v[i] << endl;

	save("소스.cpp");
}



//----------------------------------------------------------<새로운 저장>-------------------------------------------------------
파일 이름 : 소스.cpp
파일크기:659
2022-04-07 14:42:14 GMT+9

//------------------------------------<금일 강의 목표>----------------------------------
// 2022년 1학기 STL	4.07	수910목56 (6주 1일)
// 
//--------------------------------------------------------------------------------------

#include <iostream>
#include <vector>
#include <algorithm>
#include "save.h"
#include "STRING.h"
using namespace std;

extern bool 관찰;

//---------------------------
int main()
//---------------------------
{

	vector v{ 1,2,4,5 };
	// [문제] 1,2, 뒤에 3을 껴 넣어서 1,2,3,4,5,가 되도록 하시오
	v.insert(v.begin() + 2, 3);	// 벡터는 원소를 중간에 삽입/삭제는 "지양"해야한다, 그럴꺼면 리스트를 쓰자

	for (int n : v)
		cout << n << " ";
	cout << endl;

	save("소스.cpp");
}



//----------------------------------------------------------<새로운 저장>-------------------------------------------------------
파일 이름 : 소스.cpp
파일크기:1082
2022-04-07 15:15:49 GMT+9

//------------------------------------<금일 강의 목표>----------------------------------
// 2022년 1학기 STL	4.07	수910목56 (6주 1일)
// 
//--------------------------------------------------------------------------------------

#include <iostream>
#include <vector>
#include <algorithm>
#include "save.h"
#include "STRING.h"
using namespace std;

extern bool 관찰;

//---------------------------
int main()
//---------------------------
{

	vector v{ 1,2,3,4,5,6,7,8,9,10 };

	//erase(v, 7);	// 벡터에 한해서만 전역함수로 지울수 있도록 만들어R( 사용하는 것을 추천하지 않음 )

	// [문제] v에서 짝수를 제거(remove)하라.
	//remove("소스 대문자.cpp")	//파일 삭제
	//remove(v.begin(), v.end(), 9);	//처음부터 끝까지 보면서 9를 삭제하라
	//copy_if()		//조건이 맞는것만 카피해라
	auto p = remove_if(v.begin(), v.end(), [](int n) {	//지워야 하는 원소를 표시하고 불필요한 데이터를 오른쪽에 밀어넣는다. 유효한 원소까지의 it를 반환
		return (!(n & 1));	//짝수인지 확인하는 수식 !(n & 1)
	});

	v.erase(p, v.end());	//아예 p에 remove_if를 넣기도 한다.

	for (int i = 0; i < v.size(); ++i) {
		cout << v[i] << " ";
	}
	cout << endl;

	save("소스.cpp");
}



//----------------------------------------------------------<새로운 저장>-------------------------------------------------------
파일 이름 : 소스.cpp
파일크기:1189
2022-04-13 17:44:53 GMT+9

//------------------------------------<금일 강의 목표>----------------------------------
// 2022년 1학기 STL	4.13	수910목56 (6주 2일)
// 
// Containers are objects that store other objects.
// 1. Sequence container
//		array		- 유일하게 크기가 고정, []대체
//		vector		- dynamic size array, O(1) - random access
// 
//--------------------------------------------------------------------------------------

#include <iostream>
#include <array>
#include <fstream>
#include "save.h"
#include "STRING.h"
using namespace std;

// [문제] 소스.cpp를 읽어 영문자 갯수를 세라.
// 다음과 같이 출력하라
// 대소문자 구분하지 않음
// [a] - 10
// [b] - 7
// ...
// [z] - 3

//---------------------------
int main()
//---------------------------
{
	ifstream in{ "소스.cpp" };
	// 여기에 들어갈 코드를 답지에 적어라. z의 갯수를 답지에도 적어라
	char c;
	array<int, 26> arr{};	//defaul 초기화(모든 값을 0으로 채운다.)

	while (in >> c) {
		//c가 영문자이면(소문자로 바꿔) 갯수를 센다.
		if (isalpha(c)) {
			arr[tolower(c) - 'a']++;
		}
	}
	
	for (int i = 0; i < arr.size(); ++i)
		cout << "[" << char(i + 'a') << "] - " << arr[i] << endl;

	save("소스.cpp");
}

//----------------------------------------------------------<새로운 저장>-------------------------------------------------------
파일 이름 : 소스.cpp
파일크기:876
2022-04-13 18:19:00 GMT+9

//------------------------------------<금일 강의 목표>----------------------------------
// 2022년 1학기 STL	4.13	수910목56 (6주 2일)
// 
// Containers are objects that store other objects.
// 1. Sequence container
//		array		- 유일하게 크기가 고정, []대체
//		vector		- dynamic size array, O(1) - random access
// 
//--------------------------------------------------------------------------------------

#include <iostream>
#include <vector>
#include <list>
#include "save.h"
#include "STRING.h"
using namespace std;

extern bool 관찰;

//---------------------------
int main()
//---------------------------
{
	list<STRING> v{"1", "22", "4444", "55555"};

	//[문제] "22"와 "4444"사이에 "333"을 끼워 넣어라

	관찰 = true;
	v.insert(----v.cend(), "333" );
	관찰 = false;

	for (const STRING& s : v)
		cout << s << endl;

	save("소스.cpp");
}

//----------------------------------------------------------<새로운 저장>-------------------------------------------------------
파일 이름 : 소스.cpp
파일크기:742
2022-04-13 18:22:43 GMT+9

//------------------------------------<금일 강의 목표>----------------------------------
// 2022년 1학기 STL	4.13	수910목56 (6주 2일)
// 
// Containers are objects that store other objects.
// 1. Sequence container
//		array		- 유일하게 크기가 고정, []대체
//		vector		- dynamic size array, O(1) - random access
//					  중간에 insert하는 동작의 댓가를 알아봤다.
// 
//--------------------------------------------------------------------------------------

#include <iostream>
#include <deque>
#include "save.h"
#include "STRING.h"
using namespace std;

//---------------------------
int main()
//---------------------------
{
	deque<int> d;

	cout << sizeof(d) << endl;	//벡터보다 조금더 크다.

	save("소스.cpp");
}

//----------------------------------------------------------<새로운 저장>-------------------------------------------------------
파일 이름 : 소스.cpp
파일크기:1488
2022-04-13 18:55:13 GMT+9

//------------------------------------<금일 강의 목표>----------------------------------
// 2022년 1학기 STL	4.13	수910목56 (6주 2일)
// 
// Containers are objects that store other objects.
// 1. Sequence container
//		array		- 유일하게 크기가 고정, []대체
//		vector		- dynamic size array, O(1) - random access
//					  중간에 insert하는 동작의 댓가를 알아봤다.
//					  메모리가 이사갈 경우 메모리 무효화(invalidation)이 생긴다.
//		deque		- vector와 list의 짬뽕, 1000개붙어있음 <-포인터-> 1000개붙어있음
//					  []를 지원하지만 조금다르게 동작함(vector보다 느림)
//					  무효화가 생길 일이 없다.
//		list		- 임의의 위치에 추가/삭제 : O(1)
//		deque		- 연속적이지 않음
// 
//		
// 
//		span?
// 
//--------------------------------------------------------------------------------------

#include <iostream>
#include <deque>
#include <vector>
#include "save.h"
#include "STRING.h"
using namespace std;

extern bool 관찰;

class Test {
	char c[1000];

public:
	void show() const {
		cout << (long long)this << endl;
	}

};

//---------------------------
int main()
//---------------------------
{
	// [확인] vector는 연속되어 있는데 deque는 메모리가 연속되어 있지 않다고?
	// deque이 vector보다 훨씬 많은 갯수의 데이터를 가질 수 있다.(연속한 구간을 잡을 필요가 없기 때문에)

	deque<int> v(10);
	v.push_front(333);	// 앞쪽에 넣어보면 주소가 연속하지 않는다.
	v.push_back(333);

	for (int i = 0; i < v.size(); ++i) {
		cout << addressof(v[i]) << endl;
	}

	save("소스.cpp");
}

//----------------------------------------------------------<새로운 저장>-------------------------------------------------------
파일 이름 : 소스.cpp
파일크기:1555
2022-04-13 19:10:18 GMT+9

//------------------------------------<금일 강의 목표>----------------------------------
// 2022년 1학기 STL	4.13	수910목56 (6주 2일)
// 
// Containers are objects that store other objects.
// 1. Sequence container
//		array		- 유일하게 크기가 고정, []대체
//		vector		- dynamic size array, O(1) - random access
//					  중간에 insert하는 동작의 댓가를 알아봤다.
//					  메모리가 이사갈 경우 메모리 무효화(invalidation)이 생긴다.
//		deque		- vector와 list의 짬뽕, 1000개붙어있음 <-포인터-> 1000개붙어있음
//					  []를 지원하지만 조금다르게 동작함(vector보다 느림)
//					  무효화가 생길 일이 없다.
//		list		- 임의의 위치에 추가/삭제 : O(1)
//		deque		- 연속적이지 않음
// 
//		
// 
//		span?
// 
//--------------------------------------------------------------------------------------

#include <iostream>
#include <deque>
#include <vector>
#include "save.h"
#include "STRING.h"
using namespace std;

class Test {
	char c[1024];
};

//---------------------------
int main()
//---------------------------
{
	save("소스.cpp");
	
	// [확인] vector보다 deque가 더 많은 원소를 저장한다고?
	// vector가 저장한 Test 객체 수 -  17927985
	// deque이 저장한 Text 객체 수 - 확인불가
	// 
	// x86으로 변경 후
	// vector가 저장한 Test 객체 수 -  699913
	// deque이 저장한 Text 객체 수 - 2015688

	deque<Test> v;
	while (true) {
		try {
			v.push_back(Test{});	//{}라고 줄여쓸수 있다.
		}
		catch (exception& e) {
			cout << "최대 원소 수 - " << v.size() << endl;
			return 0;
		}
	}
	
}

//----------------------------------------------------------<새로운 저장>-------------------------------------------------------
파일 이름 : 소스.cpp
파일크기:1651
2022-04-14 13:50:34 GMT+9

//------------------------------------<금일 강의 목표>----------------------------------
// 2022년 1학기 STL	4.14	수910목56 (7주 1일)
// 
// Containers are objects that store other objects.
// 1. Sequence container
//		array		- 유일하게 크기가 고정, []대체
//		vector		- dynamic size array, O(1) - random access
//					  중간에 insert하는 동작의 댓가를 알아봤다.
//					  메모리가 이사갈 경우 메모리 무효화(invalidation)이 생긴다.
//		deque		- vector와 list의 짬뽕, 1000개붙어있음 <-포인터-> 1000개붙어있음
//					  []를 지원하지만 조금다르게 동작함(vector보다 느림)
//					  무효화가 생길 일이 없다.
//		list		- 임의의 위치에 추가/삭제 : O(1)
//		deque		- 연속적이지 않음
//	
//		
// 
//		span?
// 
//--------------------------------------------------------------------------------------

#include <iostream>
#include <deque>
#include <fstream>
#include <algorithm>
#include "save.h"
#include "STRING.h"
using namespace std;

extern bool 관찰;

//---------------------------
int main()
//---------------------------
{
	// [문제] "소스.cpp"의 단어를 deque에 저장하라
	// 오름차순 정렬하라
	// 출력하라.
	ifstream in{ "소스.cpp" };
	deque<string> d;

	string s;
	while (in >> s)		// (bool)(in >> s) : 제대로 읽었는지 리턴해줌
		//d.push_back(s);
		d.emplace_back(s);	// s가 이미 스트링이므로 의미가 없음, move()를 쓸경우는?

	//cout << boolalpha << (string{ "333" } < string{ "44" }) << endl;	//string은 웰노운이기 때문에 비교가 이미 정의되어 있다.
	
	sort(d.begin(), d.end());	// 자동 오름차순(ascending order) 정렬

	for (const string& str : d) {
		cout << str << endl;
	}
	
	save("소스.cpp");
}

//----------------------------------------------------------<새로운 저장>-------------------------------------------------------
파일 이름 : 소스.cpp
파일크기:1423
2022-04-14 14:06:31 GMT+9

//------------------------------------<금일 강의 목표>----------------------------------
// 2022년 1학기 STL	4.14	수910목56 (7주 1일)
// 
// Containers are objects that store other objects.
// 1. Sequence container
//		array		- 유일하게 크기가 고정, []대체
//		vector		- dynamic size array, O(1) - random access
//					  중간에 insert하는 동작의 댓가를 알아봤다.
//					  메모리가 이사갈 경우 메모리 무효화(invalidation)이 생긴다.
//		deque		- vector와 list의 짬뽕, 1000개붙어있음 <-포인터-> 1000개붙어있음
//					  []를 지원하지만 조금다르게 동작함(vector보다 느림)
//					  무효화가 생길 일이 없다.
//		list		- 임의의 위치에 추가/삭제 : O(1)
//		deque		- 연속적이지 않음
//	
//		
// 
//		span?
// 
//--------------------------------------------------------------------------------------

#include <iostream>
#include <deque>
#include <fstream>
#include <algorithm>
#include "save.h"
#include "STRING.h"
using namespace std;

extern bool 관찰;

//---------------------------
int main()
//---------------------------
{
	// [문제] "연습.txt"의 단어를 읽어 오름차순 정렬 후 출력하라

	ifstream in{ "연습.txt" };

	deque<string> d{ istream_iterator<string>{in}, {} };

	sort(d.begin(), d.end());

	// d의 각 string을 오름차순으로 정렬하라
	for (string& s : d)
		sort(s.begin(), s.end());

	copy(d.begin(), d.end(), ostream_iterator<string>{cout, "\n"});
	
	save("소스.cpp");
}

//----------------------------------------------------------<새로운 저장>-------------------------------------------------------
파일 이름 : 소스.cpp
파일크기:1478
2022-04-14 14:35:09 GMT+9

//------------------------------------<금일 강의 목표>----------------------------------
// 2022년 1학기 STL	4.14	수910목56 (7주 1일)
// 
// Containers are objects that store other objects.
// 1. Sequence container
//		array		- 유일하게 크기가 고정, []대체
//		vector		- dynamic size array, O(1) - random access
//					  중간에 insert하는 동작의 댓가를 알아봤다.
//					  메모리가 이사갈 경우 메모리 무효화(invalidation)이 생긴다.
//		deque		- vector와 list의 짬뽕, 1000개붙어있음 <-포인터-> 1000개붙어있음
//					  []를 지원하지만 조금다르게 동작함(vector보다 느림)
//					  무효화가 생길 일이 없다.
//		list		- 객체마다 포인터 2개 사용하여 삽입과 삭제 O(1)
//		deque		- 연속적이지 않음
//		
//		
// 
//		span?
// 
//--------------------------------------------------------------------------------------

#include <iostream>
#include <deque>
#include <fstream>
#include <algorithm>
#include "save.h"
#include "STRING.h"
using namespace std;

extern bool 관찰;

//---------------------------
int main()
//---------------------------
{

	ifstream in{ "연습.txt" };

	deque<string> d{ istream_iterator<string>{in}, {} };
	// "dynamic"은 몇 번째 단어인가?
	auto pos = find(d.begin(), d.end(), "dynamic");	// find함수는 순차적으로 비교하여 
	if (pos == d.end()) {
		cout << "없는 단어입니다" << endl;
	}
	else {
		cout << pos - d.begin() + 1 << "번째 단어입니다." << endl;
	}

	//find_if(d.begin(), d.end(), )

	save("소스.cpp");
}

//----------------------------------------------------------<새로운 저장>-------------------------------------------------------
파일 이름 : 소스.cpp
파일크기:1653
2022-04-14 14:58:12 GMT+9

//------------------------------------<금일 강의 목표>----------------------------------
// 2022년 1학기 STL	4.14	수910목56 (7주 1일)
// 
// Containers are objects that store other objects.
// 1. Sequence container
//		array		- 유일하게 크기가 고정, []대체
//		vector		- dynamic size array, O(1) - random access
//					  중간에 insert하는 동작의 댓가를 알아봤다.
//					  메모리가 이사갈 경우 메모리 무효화(invalidation)이 생긴다.
//		deque		- vector와 list의 짬뽕, 1000개붙어있음 <-포인터-> 1000개붙어있음
//					  []를 지원하지만 조금다르게 동작함(vector보다 느림)
//					  무효화가 생길 일이 없다.
//		list		- 객체마다 포인터 2개 사용하여 삽입과 삭제 O(1)
//		deque		- 연속적이지 않음
//		
//		
// 
//		span?
// 
//--------------------------------------------------------------------------------------

#include <iostream>
#include <list>
#include <deque>
#include <fstream>
#include <algorithm>
#include "save.h"
#include "STRING.h"
using namespace std;

extern bool 관찰;

//---------------------------
int main()
//---------------------------
{

	ifstream in{ "연습.txt" };

	list<string> cont;

	string s;
	while (in >> s) {
		cont.push_back(move(s));	// 어차피 문자의 길이가 15가 안넘기므로 move의 의미는 없다.
		s.clear();
	}

	// [문제] 정렬하라
	// [문제] 뒤에서 부터 10개 단어만 출력하라.
	
	//sort(cont.begin(), cont.end());	// sort함수는 메모리가 붙어있어야함 (deque는 예외), 따라서 list는 정렬이 안됨
	cont.sort();

	//istream_iterator<string> p{ in }; 라고 쓸수 도 있다.
	auto p = cont.crbegin();
	for (int i = 0; i < 10; ++i) {
		cout << *p++ << endl;
	}

	save("소스.cpp");
}

//----------------------------------------------------------<새로운 저장>-------------------------------------------------------
파일 이름 : 소스.cpp
파일크기:1579
2022-04-14 15:11:39 GMT+9

//------------------------------------<금일 강의 목표>----------------------------------
// 2022년 1학기 STL	4.14	수910목56 (7주 1일)
// 
// Containers are objects that store other objects.
// 1. Sequence container
//		array		- 유일하게 크기가 고정, []대체
//		vector		- dynamic size array, O(1) - random access
//					  중간에 insert하는 동작의 댓가를 알아봤다.
//					  메모리가 이사갈 경우 메모리 무효화(invalidation)이 생긴다.
//		deque		- vector와 list의 짬뽕, 1000개붙어있음 <-포인터-> 1000개붙어있음
//					  []를 지원하지만 조금다르게 동작함(vector보다 느림)
//					  무효화가 생길 일이 없다.
//		list		- 객체마다 포인터 2개 사용하여 삽입과 삭제 O(1)
//		deque		- 연속적이지 않음
//		
//		
// 
//		span?
// 
//--------------------------------------------------------------------------------------

#include <iostream>
#include <list>
#include <deque>
#include <fstream>
#include <algorithm>
#include "save.h"
#include "STRING.h"
using namespace std;

extern bool 관찰;

//---------------------------
int main()
//---------------------------
{

	ifstream in{ "연습.txt" };

	list<string> cont;

	string s;
	while (in >> s) {
		cont.push_back(move(s));	// 어차피 문자의 길이가 15가 안넘기므로 move의 의미는 없다.
		s.clear();
	}

	// [문제] "dynamic"은 몇 번째 단어인가 출력하라?
	auto p = find(cont.begin(), cont.end(), "dynamic");
	if (p == cont.end())
		cout << "못찾음" << endl;
	else
		cout << distance(cont.begin(), p) + 1 << "번째 단어" << endl;	// begin부터 p까지 while을 돌면서 세어간다.

	save("소스.cpp");
}

//----------------------------------------------------------<새로운 저장>-------------------------------------------------------
파일 이름 : 소스.cpp
파일크기:1318
2022-04-14 15:14:40 GMT+9

//------------------------------------<금일 강의 목표>----------------------------------
// 2022년 1학기 STL	4.14	수910목56 (7주 1일)
// 
// Containers are objects that store other objects.
// 1. Sequence container
//		array		- 유일하게 크기가 고정, []대체
//		vector		- dynamic size array, O(1) - random access
//					  중간에 insert하는 동작의 댓가를 알아봤다.
//					  메모리가 이사갈 경우 메모리 무효화(invalidation)이 생긴다.
//		deque		- vector와 list의 짬뽕, 1000개붙어있음 <-포인터-> 1000개붙어있음
//					  []를 지원하지만 조금다르게 동작함(vector보다 느림)
//					  무효화가 생길 일이 없다.
//		list		- 객체마다 포인터 2개 사용하여 삽입과 삭제 O(1)
//		deque		- 연속적이지 않음
//		
//		
// 
//		span?
// 
//--------------------------------------------------------------------------------------

#include <iostream>
#include <list>
#include <deque>
#include <fstream>
#include <algorithm>
#include "save.h"
#include "STRING.h"
using namespace std;

extern bool 관찰;

//---------------------------
int main()
//---------------------------
{

	ifstream in{ "연습.txt" };

	list<char> cont;

	char c;
	while (in >> c)
		cont.push_back(c);

	// [문제] a가 몇 개 있나 출력하라?
	cout << "a의 갯수 - " << count(cont.begin(), cont.end(), 'a');

	save("소스.cpp");
}

//----------------------------------------------------------<새로운 저장>-------------------------------------------------------
파일 이름 : 소스.cpp
파일크기:1512
2022-04-14 15:19:58 GMT+9

//------------------------------------<금일 강의 목표>----------------------------------
// 2022년 1학기 STL	4.14	수910목56 (7주 1일)
// 
// Containers are objects that store other objects.
// 1. Sequence container
//		array		- 유일하게 크기가 고정, []대체
//		vector		- dynamic size array, O(1) - random access
//					  중간에 insert하는 동작의 댓가를 알아봤다.
//					  메모리가 이사갈 경우 메모리 무효화(invalidation)이 생긴다.
//		deque		- vector와 list의 짬뽕, 1000개붙어있음 <-포인터-> 1000개붙어있음
//					  []를 지원하지만 조금다르게 동작함(vector보다 느림)
//					  무효화가 생길 일이 없다.
//		list		- 객체마다 포인터 2개 사용하여 삽입과 삭제 O(1)
//		deque		- 연속적이지 않음
//		
//		
// 
//		span?
// 
//--------------------------------------------------------------------------------------

#include <iostream>
#include <list>
#include <deque>
#include <fstream>
#include <algorithm>
#include "save.h"
#include "STRING.h"
using namespace std;

extern bool 관찰;

//---------------------------
int main()
//---------------------------
{

	ifstream in{ "연습.txt" };

	list<string> cont;

	string s;
	while (in >> s)
		cont.push_back(s);

	// [문제] 글자수가 5개인 것만 화면 출력

	// 방법1
	copy_if(cont.begin(), cont.end(), ostream_iterator<string>{cout, "\n"},
		[](const string& s) {
			return s.size() == 5;
		});

	cout << endl;
	// 방법2
	for (const string& s : cont)
		if (s.size() == 5)
			cout << s << endl;

	save("소스.cpp");
}

//----------------------------------------------------------<새로운 저장>-------------------------------------------------------
파일 이름 : 소스.cpp
파일크기:4166
2022-04-21 14:12:50 GMT+9

//------------------------------------<금일 강의 목표>----------------------------------
// 2022년 1학기 STL	4.21	수910목56 (8주 1일)
// 
// Containers are objects that store other objects.
// 1. Sequence container
//		array		- 유일하게 크기가 고정, []대체
//		vector		- dynamic size array, O(1) - random access
//					  중간에 insert하는 동작의 댓가를 알아봤다.
//					  메모리가 이사갈 경우 메모리 무효화(invalidation)이 생긴다.
//		deque		- vector와 list의 짬뽕, 1000개붙어있음 <-포인터-> 1000개붙어있음
//					  []를 지원하지만 조금다르게 동작함(vector보다 느림)
//					  무효화가 생길 일이 없다.
//		list		- 객체마다 포인터 2개 사용하여 삽입과 삭제 O(1)
//		deque		- 연속적이지 않음
// 
//		span?
// 
//
//--------------------------------------------------------------------------------------

#include <iostream>
#include <list>
#include <vector>
#include <numeric>
#include <array>
#include <deque>
#include <fstream>
#include <algorithm>
#include <format>
#include "save.h"
#include "STRING.h"
using namespace std;

class Test {
	int id;								// 일련번호
	string word;						// 단어

public:
	Test() = default;
	Test(int _id, string& _word) : id{ _id }, word{ _word }{

	}

	friend istream& operator>>(istream& is, Test& t) {
		is >> t.id >> t.word;
		return is;
	}

	int getId() const {
		return id;
	}

	string getWord() const {
		return word;
	}

	void show() const {
		cout << format("id:{:>5d} 단어: {}", id, word) << endl;
		// cout << "id:" << id << " 단어:" << word << endl;
	}

	void write(ostream& os) const {
		os << id << " " << word << " ";
	}

	bool read(istream& is) {
		return bool(is >> id >> word);
	}

};

//---------------------------
int main()
//---------------------------
{
	save("소스.cpp");

	ifstream in{ "시험자료.txt" };

	// [문제 1] Test 객체를 모두 읽어 컨테이너에 저장하라.
	// 모두 몇 객체가 있는지 출력하고 답지에 출력된 갯수도 적어라.	          
	// Test 객체를 읽기 위해 필요한 멤버함수를 추가할 수 있다.
	// 답지에 관련 코드를 모두 적어라.

	vector<Test> v;
	v.reserve(10'000);
	int id;
	string word;
	while (in >> id >> word)
		v.emplace_back(id, word);
	cout << v.size() << "개의 Test가 있습니다." << endl;

	//Test t;
	//while (t.read(in)){
	//	v.push_back(t);
	//}

	// [문제 2] 컨테이너의 Test 객체 중 word의 길이가 가장 긴 객체를 화면에 출력하라.		
	// 출력된 결과를 답지에도 적어라.								
	// 출력은 멤버함수 show()를 사용하라.

	max_element(v.begin(), v.end(), [](const Test& a, const Test& b) {
		return a.getWord().size() < b.getWord().size();
		})->show();

	// [문제 3] 컨테이너를 Test 객체 id 기준 오름차순으로 정렬하라.
	// 제일 마지막 객체를 show()로 출력하고 답지에도 적어라.		

	sort(v.begin(), v.end(), [](const Test& a,const Test& b) {
		return a.getId() < b.getId();
		});
	v.crbegin()->show();

	// [문제 4] 단어를 입력받아 같은 단어가 있는 Test 객체를 검색하는 코드를 작성하라.
	// word가 같은 객체가 몇 개인지 세서 출력하고,					
	// 찾는 객체가 있다면 모두 화면에 출력하도록 하라.				
	// (주의) 이 코드는 계속 실행되어야 한다.				
	// (실행화면의 화면 출력을 참고하라)
	//library
	//algorithm
	//yesterday
	//extraordinary
	//corona

	cout << "단어를 검색합니다" << endl;
	while (true) {
		string word;
		cout << "찾으려는 단어를 입력하세요: ";
		cin >> word;

		// 여기 들어갈 코드를 작성하면 된다.
		int cnt = count_if(v.begin(), v.end(), [word](const Test& t) {
			return word == t.getWord();	//캡쳐
			});
		cout << word << "는 모두 " << cnt << "개 있습니다." << endl;
		
		if (cnt == 0)
			continue;

		//auto b = v.begin();
		//for (int i = 0; i < cnt; ++i) {
		//	auto p = find_if(b, v.end(), [word](const Test& t) {
		//		return word == t.getWord();	//캡쳐
		//		});
		//	p->show();
		//	b = p + 1;
		//}

		for (const Test& t : v)
			if (t.getWord() == word)
				t.show();


		//vector<Test*> vp;
		//for (Test& t : v)
		//	if (t.getWord() == word)
		//		vp.push_back(&t);

		//cout << "word가 " << word << "인 객체의 수 - " << vp.size() << endl;
		//for (Test* tp : vp)
		//	tp->show();
		//cout << endl;

	}
	

	
}

//----------------------------------------------------------<새로운 저장>-------------------------------------------------------
파일 이름 : 소스.cpp
파일크기:1228
2022-04-21 14:54:22 GMT+9

//------------------------------------<금일 강의 목표>----------------------------------
// 2022년 1학기 STL	4.21	수910목56 (8주 1일)
// 
// Containers are objects that store other objects.
// 1. Sequence container
//		...
//		forward_list- 시공간상의 오버헤드가 0인 C스타일의 단일 링크드 리스트
//						시간이 걸리는 행동을 제공하지 않는다.
//		...
// 
// 2. Associative container
//		
// 
// 
// iterator - 포인터를 (generalization)일반화한것
//				데이터 구조와 상관없이 일관된 방식으로 작동하도록하는것
//
//--------------------------------------------------------------------------------------

#include <iostream>
#include "save.h"
#include "STRING.h"
using namespace std;

//---------------------------
int main()
//---------------------------
{
	// 출력반복자를 통해 반복자가 제공하는 연산을 이해해본다.
	ostream_iterator<char> p{ cout };
	p.operator*() = 'A';	//출력반복자는 알아서 이동하기 때문에 이동명령을 할 필요 없다.
	*p = 'B';
	p = 'C';	//*이 필요가 없다. (그냥 이렇게 쓰면 된다.)

	//그럼 ++과 *을 왜 만들었을까?
	//기존의 포인터가 그러한 동작이 있기때문에 행동하지 않지만 구현은 해놓았다.
	//int* p;	의 경우 *p; p++; p ==q; 과 같은 기능이 있기때문에

	save("소스.cpp");
}

//----------------------------------------------------------<새로운 저장>-------------------------------------------------------
파일 이름 : 소스.cpp
파일크기:1220
2022-04-21 15:07:39 GMT+9

//------------------------------------<금일 강의 목표>----------------------------------
// 2022년 1학기 STL	4.21	수910목56 (8주 1일)
// 
// Containers are objects that store other objects.
// 1. Sequence container
//		...
//		forward_list- 시공간상의 오버헤드가 0인 C스타일의 단일 링크드 리스트
//						시간이 걸리는 행동을 제공하지 않는다.
//		...
// 
// 2. Associative container
//		
// 
// 
// iterator - 포인터를 (generalization)일반화한것
//				데이터 구조와 상관없이 일관된 방식으로 작동하도록하는것
//
//--------------------------------------------------------------------------------------

#include <iostream>
#include <vector>

#include "save.h"
#include "STRING.h"

using namespace std;

template<class Iter>
void show( Iter ) 
{
	//_Is_iterator	//표준은 아님
	// 표준은 concept를 이용해서 ~~~~?
	cout << typeid(iterator_traits<Iter>::iterator_category).name() << endl;
}

//---------------------------
int main()
//---------------------------
{
	// 반복자를 인자로 받아 어떤 반복자인지 출력해주면 좋겠다.
	// [문제] show 함수는 반복자를 인자로 받아 어떤 종류인지 출력한다.
	// show를 선언하고 정의하라

	vector<int> v;

	//show(v.begin());
	show(istream_iterator<char>());	//입력
	show(ostream_iterator<char>{cout});	//출력
	show(forward_list<char>::iterator{});	// 단방향
	show(list<char>::iterator{});	// 양방향
	show(deque<char>::iterator{});	// 랜덤 엑세스
	show(vector<char>::iterator{});	// 랜덤 엑세스(컨티구어스)

	int* p{};
	show(p);

	save("소스.cpp");
}

//----------------------------------------------------------<새로운 저장>-------------------------------------------------------
파일 이름 : 소스.cpp
파일크기:1227
2022-04-27 18:44:54 GMT+9

//------------------------------------<금일 강의 목표>----------------------------------
// 2022년 1학기 STL	4.27	수910목56 (8주 2일)
// 
// c++ execution policy??
// 
// Containers are objects that store other objects.
// 1. Sequence container
//		...
//		forward_list- 시공간상의 오버헤드가 0인 C스타일의 단일 링크드 리스트
//						시간이 걸리는 행동을 제공하지 않는다.
//		...
// 
// 2. Associative container
//		
// 
// 
// iterator - 포인터를 (generalization)일반화한것
//				데이터 구조와 상관없이 일관된 방식으로 작동하도록하는것
//	반복자 어댑터 : 반복자을 한단계더 감싸서 반복자 처럼 행동하는 녀석,
//					대표적으로 입출력 반복자, 역방향 반복자, 삽입 반복자, 이동 반복자
// 
//	역방향 반복자 - 반드시 class로 만들어야 한다
//					++연산이 실제로는 왼쪽으로 가야되기 때문이다.
// 
//--------------------------------------------------------------------------------------

#include <iostream>
#include <string>

#include "save.h"
#include "STRING.h"

using namespace std;

//---------------------------
int main()
//---------------------------
{
	STRING s{ "Hello" };

	for (auto i = s.rbegin(); i != s.rend(); ++i)
		cout << *i << " - ";
	cout << endl;

	save("소스.cpp");
}

//----------------------------------------------------------<새로운 저장>-------------------------------------------------------
파일 이름 : 소스.cpp
파일크기:1303
2022-04-28 14:01:38 GMT+9

//------------------------------------<금일 강의 목표>----------------------------------
// 2022년 1학기 STL	4.28	수910목56 (9주 1일)
// 
// c++ execution policy??
// 
// Containers are objects that store other objects.
// 1. Sequence container
//		...
//		forward_list- 시공간상의 오버헤드가 0인 C스타일의 단일 링크드 리스트
//						시간이 걸리는 행동을 제공하지 않는다.
//		...
// 
// 2. Associative container
//		
// 
// 
// iterator - 포인터를 (generalization)일반화한것
//				데이터 구조와 상관없이 일관된 방식으로 작동하도록하는것
//	반복자 어댑터 : 반복자을 한단계더 감싸서 반복자 처럼 행동하는 녀석,
//					대표적으로 입출력 반복자, 역방향 반복자, 삽입 반복자, 이동 반복자
// 
//	역방향 반복자 - 반드시 class로 만들어야 한다
//					++연산이 실제로는 왼쪽으로 가야되기 때문이다.
// 
//--------------------------------------------------------------------------------------

#include <iostream>
#include <string>
#include <algorithm>

#include "save.h"
#include "STRING.h"

using namespace std;

//---------------------------
int main()
//---------------------------
{

	STRING s{ "the quick brown fox jumps over the lazy dog" };

	sort(s.begin(), s.end());

	//s.erase( unique(s.begin(), s.end()), s.end());
	cout << s << endl;

	save("소스.cpp");
}

//----------------------------------------------------------<새로운 저장>-------------------------------------------------------
파일 이름 : 소스.cpp
파일크기:1525
2022-04-28 14:45:54 GMT+9

//------------------------------------<금일 강의 목표>----------------------------------
// 2022년 1학기 STL	4.28	수910목56 (9주 1일)
// 
// c++ execution policy??
// 
// Containers are objects that store other objects.
// 1. Sequence container
//		...
//		forward_list- 시공간상의 오버헤드가 0인 C스타일의 단일 링크드 리스트
//						시간이 걸리는 행동을 제공하지 않는다.
//		...
// 
// 2. Associative container
//		
// 
// 
// iterator - 포인터를 (generalization)일반화한것
//				데이터 구조와 상관없이 일관된 방식으로 작동하도록하는것
//	반복자 어댑터 : 반복자을 한단계더 감싸서 반복자 처럼 행동하는 녀석,
//					대표적으로 입출력 반복자, 역방향 반복자, 삽입 반복자, 이동 반복자
// 
//	역방향 반복자 - 반드시 class로 만들어야 한다
//					++연산이 실제로는 왼쪽으로 가야되기 때문이다.
// 
//--------------------------------------------------------------------------------------

#include <iostream>
#include <string>
#include <algorithm>
#include <fstream>
#include <vector>

#include "save.h"
#include "STRING.h"

using namespace std;

bool operator<(const STRING& a, const STRING& b)
{
	// 사전식 정렬
	return string(a.begin(), a.end()) < string(b.begin(), b.end());
}

//---------------------------
int main()
//---------------------------
{
	ifstream in{ "소스.cpp" };

	vector<STRING> v{istream_iterator<STRING>{in}, {} };

	// [문제] v를 정렬하라				STRING < STRING
	sort(v.begin(), v.end());

	for (auto s : v) {
		cout << s << endl;
	}

	save("소스.cpp");
}

//----------------------------------------------------------<새로운 저장>-------------------------------------------------------
파일 이름 : 소스.cpp
파일크기:1427
2022-04-28 14:49:45 GMT+9

//------------------------------------<금일 강의 목표>----------------------------------
// 2022년 1학기 STL	4.28	수910목56 (9주 1일)
// 
// c++ execution policy??
// 
// Containers are objects that store other objects.
// 1. Sequence container
//		...
//		forward_list- 시공간상의 오버헤드가 0인 C스타일의 단일 링크드 리스트
//						시간이 걸리는 행동을 제공하지 않는다.
//		...
// 
// 2. Associative container
//		
// 
// 
// iterator - 포인터를 (generalization)일반화한것
//				데이터 구조와 상관없이 일관된 방식으로 작동하도록하는것
//	반복자 어댑터 : 반복자을 한단계더 감싸서 반복자 처럼 행동하는 녀석,
//					대표적으로 입출력 반복자, 역방향 반복자, 삽입 반복자, 이동 반복자
// 
//	역방향 반복자 - 반드시 class로 만들어야 한다
//					++연산이 실제로는 왼쪽으로 가야되기 때문이다.
// 
//--------------------------------------------------------------------------------------

#include <iostream>
#include <string>
#include <algorithm>
#include <fstream>
#include <vector>

#include "save.h"
#include "STRING.h"

using namespace std;

//---------------------------
int main()
//---------------------------
{
	ifstream in{ "소스.cpp" };

	vector<STRING> v{istream_iterator<STRING>{in}, {} };

	// [문제] v를 정렬하라				STRING < STRING
	sort(v.begin(), v.end());	// lexico(사전식 비교)를 하는 방법이 있다.

	for (auto s : v) {
		cout << s << endl;
	}

	save("소스.cpp");
}

//----------------------------------------------------------<새로운 저장>-------------------------------------------------------
파일 이름 : 소스.cpp
파일크기:1499
2022-04-28 14:50:34 GMT+9

//------------------------------------<금일 강의 목표>----------------------------------
// 2022년 1학기 STL	4.28	수910목56 (9주 1일)
// 
// c++ execution policy??
// 
// Containers are objects that store other objects.
// 1. Sequence container
//		...
//		forward_list- 시공간상의 오버헤드가 0인 C스타일의 단일 링크드 리스트
//						시간이 걸리는 행동을 제공하지 않는다.
//		...
// 
// 2. Associative container
//		
// 
// 
// iterator - 포인터를 (generalization)일반화한것
//				데이터 구조와 상관없이 일관된 방식으로 작동하도록하는것
//	반복자 어댑터 : 반복자을 한단계더 감싸서 반복자 처럼 행동하는 녀석,
//					대표적으로 입출력 반복자, 역방향 반복자, 삽입 반복자, 이동 반복자
// 
//	역방향 반복자 - 반드시 class로 만들어야 한다
//					++연산이 실제로는 왼쪽으로 가야되기 때문이다.
// 
//--------------------------------------------------------------------------------------

#include <iostream>
#include <string>
#include <algorithm>
#include <fstream>
#include <vector>

#include "save.h"
#include "STRING.h"

using namespace std;

//---------------------------
int main()
//---------------------------
{
	ifstream in{ "소스.cpp" };

	vector<STRING> v{istream_iterator<STRING>{in}, {} };

	// [문제] v를 정렬하라				STRING < STRING
	sort(v.begin(), v.end(), [](const STRING& a, const STRING& b) {
		return a.getNum() < b.getNum();
		});	// 람다식으로 길이를 기준으로 정렬

	for (auto s : v) {
		cout << s << endl;
	}

	save("소스.cpp");
}

//----------------------------------------------------------<새로운 저장>-------------------------------------------------------
파일 이름 : 소스.cpp
파일크기:1557
2022-04-28 14:55:29 GMT+9

//------------------------------------<금일 강의 목표>----------------------------------
// 2022년 1학기 STL	4.28	수910목56 (9주 1일)
// 
// c++ execution policy??
// 
// Containers are objects that store other objects.
// 1. Sequence container
//		...
//		forward_list- 시공간상의 오버헤드가 0인 C스타일의 단일 링크드 리스트
//						시간이 걸리는 행동을 제공하지 않는다.
//		...
// 
// 2. Associative container
//		
// 
// 
// iterator - 포인터를 (generalization)일반화한것
//				데이터 구조와 상관없이 일관된 방식으로 작동하도록하는것
//	반복자 어댑터 : 반복자을 한단계더 감싸서 반복자 처럼 행동하는 녀석,
//					대표적으로 입출력 반복자, 역방향 반복자, 삽입 반복자, 이동 반복자
// 
//	역방향 반복자 - 반드시 class로 만들어야 한다
//					++연산이 실제로는 왼쪽으로 가야되기 때문이다.
// 
//--------------------------------------------------------------------------------------

#include <iostream>
#include <string>
#include <algorithm>
#include <fstream>
#include <vector>

#include "save.h"
#include "STRING.h"

using namespace std;

//---------------------------
int main()
//---------------------------
{
	ifstream in{ "소스X.cpp" };

	vector<STRING> v{istream_iterator<STRING>{in}, {} };

	sort(v.begin(), v.end(), [](const STRING& a, const STRING& b) {
		return a.getNum() < b.getNum();
		});	// 람다식으로 길이를 기준으로 정렬

	// [문제] v의 각 원소를 오름차순으로 정렬하라
	for (STRING& s : v)
		sort(s.begin(), s.end());

	for (auto s : v) {
		cout << s << endl;
	}

	save("소스.cpp");
}

//----------------------------------------------------------<새로운 저장>-------------------------------------------------------
파일 이름 : 소스.cpp
파일크기:1888
2022-04-28 15:22:53 GMT+9

//------------------------------------<금일 강의 목표>----------------------------------
// 2022년 1학기 STL	4.28	수910목56 (9주 1일)
// 
// c++ execution policy??
// 
// Containers are objects that store other objects.
// 1. Sequence container
//		...
//		forward_list- 시공간상의 오버헤드가 0인 C스타일의 단일 링크드 리스트
//						시간이 걸리는 행동을 제공하지 않는다.
//		...
// 
// 2. Associative container
//		
// 
// 
// iterator - 포인터를 (generalization)일반화한것
//				데이터 구조와 상관없이 일관된 방식으로 작동하도록하는것
//	반복자 어댑터 : 반복자을 한단계더 감싸서 반복자 처럼 행동하는 녀석,
//					대표적으로 입출력 반복자, 역방향 반복자, 삽입 반복자, 이동 반복자
// 
//	역방향 반복자 - 반드시 class로 만들어야 한다
//					++연산이 실제로는 왼쪽으로 가야되기 때문이다.
// 
// iterator traits(특질)
// 
// https://en.wikipedia.org/wiki/Weak_ordering
//--------------------------------------------------------------------------------------

#include <iostream>
#include <string>
#include <algorithm>
#include <fstream>
#include <vector>

#include "save.h"
#include "STRING.h"

using namespace std;

template<class Iter, class Val>
Iter my_find(Iter first, Iter last, const Val& v) {
	while (first != last) {
		if (*first == v)
			return first;
		++first;
	}
	return last;
}

//---------------------------
int main()
//---------------------------
{
	save("소스.cpp");

	STRING word;
	cout << "단어를 입력하세요: ";
	cin >> word;

	// [문제] 어떤 문자가 입력받은 단어의 몇 번째 문자인지 출력하라
	while (true) {
		cout << "문자를 입력하세요: ";
		char c;
		cin >> c;
		
		auto p = my_find(word.begin(), word.end(), c);

		if (p == word.end())
			cout << "없는 글자입니다." << endl;
		else
			cout << c << "는 " << distance(word.begin(), p) + 1 << "번째 문자입니다." << endl;;
	}

	//save("소스.cpp");
}

//----------------------------------------------------------<새로운 저장>-------------------------------------------------------
파일 이름 : 소스.cpp
파일크기:1372
2022-05-04 18:09:44 GMT+9

//------------------------------------<금일 강의 목표>----------------------------------
// 2022년 1학기 STL	5.4	수910목56 (9주 2일)
// 
// 1. Sequence container
// 2. Associative container
// 
// total ordering이란?
// <으로 같음을 판정  -> 상등(equivalence)
// ==으로 같음을 판정 -> 항등(quality)
// 
// 오늘 알아볼 것
//  - 제네릭 프로그래밍의 재미
// 
//--------------------------------------------------------------------------------------

#include <iostream>
#include <string>
#include <algorithm>
#include <fstream>
#include <vector>

#include "save.h"
#include "STRING.h"

using namespace std;

template<class Iter, class Func>	// Func을 Callable타입이라고 한다.
Iter myfind_if(Iter beg, Iter end, Func func) {
	while (beg != end) {
		if (func(*beg)) {
			return beg;
		}
		++beg;
	}
	return beg;

}

//---------------------------
int main()
//---------------------------
{
	save("소스.cpp");
	// [문제] 아무 단어나 입력받자.
	// 그 단어에서 첫 대문자 위치를 리턴하라

	while (true) {
		cout << "단어를 입력하세요 : ";
		STRING s;	// loop optimization 루프 최적화
		cin >> s;

		auto p = myfind_if(s.begin(), s.end(), [](char c) {
			return isupper(c);
			});

		if (p == s.end())
			cout << "대문자가 없다." << endl;
		else
			cout << distance(s.begin(), p) + 1 << "에 대문자 발견" << endl;

	}

	
}

//----------------------------------------------------------<새로운 저장>-------------------------------------------------------
파일 이름 : 소스.cpp
파일크기:1514
2022-05-04 18:14:33 GMT+9

//------------------------------------<금일 강의 목표>----------------------------------
// 2022년 1학기 STL	5.4	수910목56 (9주 2일)
// 
// 1. Sequence container
// 2. Associative container
// 
// total ordering이란?
// <으로 같음을 판정  -> 상등(equivalence)
// ==으로 같음을 판정 -> 항등(quality)
// 
// 오늘 알아볼 것
//  - 제네릭 프로그래밍의 재미
// 
//--------------------------------------------------------------------------------------

#include <iostream>
#include <string>
#include <algorithm>

#include "save.h"
#include "STRING.h"

using namespace std;

template<class Iter, class Func>	// Func을 Callable타입이라고 한다.
Iter myfind_if(Iter beg, Iter end, Func func) {
	while (beg != end) {
		if (func(*beg)) {
			return beg;
		}
		++beg;
	}
	return beg;

}

class 람다 {
public:
	bool operator()(char c) {
		cout << "f를 호출해서 판정" << endl;
		return isupper(c);
	}
};


//---------------------------
int main()
//---------------------------
{
	save("소스.cpp");
	// [문제] 아무 단어나 입력받자.
	// 그 단어에서 첫 대문자 위치를 리턴하라

	while (true) {
		cout << "단어를 입력하세요 : ";
		STRING s;	// loop optimization 루프 최적화
		cin >> s;

		auto p = myfind_if(s.begin(), s.end(), 람다());	// 람다는 클래스로 만들어져서 다음과 같이 실행된다.

		if (p == s.end())
			cout << "대문자가 없다." << endl;
		else
			cout << distance(s.begin(), p) + 1 << "에 대문자 발견" << endl;

	}

	
}

//----------------------------------------------------------<새로운 저장>-------------------------------------------------------
파일 이름 : 소스.cpp
파일크기:1007
2022-05-04 18:27:38 GMT+9

//------------------------------------<금일 강의 목표>----------------------------------
// 2022년 1학기 STL	5.4	수910목56 (9주 2일)
// 
// 1. Sequence container
// 2. Associative container
// 
// total ordering이란?
// <으로 같음을 판정  -> 상등(equivalence)
// ==으로 같음을 판정 -> 항등(quality)
// 
// 오늘 알아볼 것
//  - 제네릭 프로그래밍의 재미
// 
//--------------------------------------------------------------------------------------

#include <iostream>
#include <string>
#include <algorithm>

#include "save.h"
#include "STRING.h"

using namespace std;

template<class SrcIter, class DesIter>
void my_copy(SrcIter b, SrcIter e, DesIter d)
{
	while (b != e) {
		*d = *b;
		++d;
		++b;
	}
}

//---------------------------
int main()
//---------------------------
{

	// [문제] 키보드에서 입력한 글자를 모니터에 출력하라
	// copy 알고리즘을 사용할 것
	my_copy(istreambuf_iterator<char>{cin}, {}, ostream_iterator<char>{cout, "*"});

	save("소스.cpp");
}

//----------------------------------------------------------<새로운 저장>-------------------------------------------------------
파일 이름 : 소스.cpp
파일크기:1272
2022-05-04 18:47:52 GMT+9

//------------------------------------<금일 강의 목표>----------------------------------
// 2022년 1학기 STL	5.4	수910목56 (9주 2일)
// 
// 1. Sequence container
// 2. Associative container
// 
// total ordering이란?
// <으로 같음을 판정  -> 상등(equivalence)
// ==으로 같음을 판정 -> 항등(quality)
// 
// 오늘 알아볼 것
//  - 제네릭 프로그래밍의 재미
// 
//--------------------------------------------------------------------------------------

#include <iostream>
#include <vector>
#include <string>
#include <algorithm>

#include "save.h"
#include "STRING.h"

using namespace std;

template<class SrcIter, class DesIter>
void my_copy(SrcIter b, SrcIter e, DesIter d)
{
	while (b != e) {
		*d++ = *b++;
	}
}

//---------------------------
int main()
//---------------------------
{

	// [문제] 키보드에서 입력한 글자를 벡터에 저장하라
	// copy 알고리즘을 사용할 것

	//vector<char> v(istreambuf_iterator<char>{cin}, {});
	vector<char> v;
	v.reserve(100);
	my_copy(istreambuf_iterator<char>{cin}, {}, v.begin());

	// 공간을 잡아서 복사를 했지만 vector의 size는 그대로 이기때문에 문제가 생긴다.
	for (int i = 0; i < 100; ++i) {
		cout << v[i] << "-";
	}
	cout << endl;
	cout << v.size() << endl;

	save("소스.cpp");
}

//----------------------------------------------------------<새로운 저장>-------------------------------------------------------
파일 이름 : 소스.cpp
파일크기:1302
2022-05-04 18:55:42 GMT+9

//------------------------------------<금일 강의 목표>----------------------------------
// 2022년 1학기 STL	5.4	수910목56 (9주 2일)
// 
// 1. Sequence container
// 2. Associative container
// 
// total ordering이란?
// <으로 같음을 판정  -> 상등(equivalence)
// ==으로 같음을 판정 -> 항등(quality)
// 
// 오늘 알아볼 것
//  - 제네릭 프로그래밍의 재미
// 
// 역방향 반복자와 삽입 반복자
// 
//--------------------------------------------------------------------------------------

#include <iostream>
#include <vector>
#include <string>
#include <algorithm>

#include "save.h"
#include "STRING.h"

using namespace std;

template<class SrcIter, class DesIter>
void my_copy(SrcIter b, SrcIter e, DesIter d)
{
	while (b != e) {
		*d++ = *b++;
	}
}

//---------------------------
int main()
//---------------------------
{

	// [문제] 키보드에서 입력한 글자를 벡터에 저장하라
	// copy 알고리즘을 사용할 것

	vector<char> v;
	//vector<char> v{'d','f','g'};	// insert_iterator는 뒤에 이에서 카피된다.
	my_copy(istreambuf_iterator<char>{cin}, {}, back_inserter(v));

	// 공간을 잡아서 복사를 했지만 vector의 size는 그대로 이기때문에 문제가 생긴다.
	for (char c : v) {
		cout << c << "-";
	}
	cout << endl;
	cout << v.size() << endl;

	save("소스.cpp");
}

//----------------------------------------------------------<새로운 저장>-------------------------------------------------------
파일 이름 : 소스.cpp
파일크기:1151
2022-05-04 19:06:44 GMT+9

//------------------------------------<금일 강의 목표>----------------------------------
// 2022년 1학기 STL	5.4	수910목56 (9주 2일)
// 
// 1. Sequence container
// 2. Associative container
// 
// total ordering이란?
// <으로 같음을 판정  -> 상등(equivalence)
// ==으로 같음을 판정 -> 항등(quality)
// 
// 오늘 알아볼 것
//  - 제네릭 프로그래밍의 재미
//  - span : contiguous 컨테이너를 일관된 방식으로 다루기 위해 만든 view
//				T[], array<T, N>, vector<T>, string, STRING
// 
// 역방향 반복자와 삽입 반복자
// 
// 
//--------------------------------------------------------------------------------------

#include <iostream>
#include <vector>
#include <string>
#include <algorithm>

#include "save.h"
#include "STRING.h"

using namespace std;

void print(int[10]);

void print(int a[10])
{
	for (int i = 0; i < 10; ++i)
		cout << a[i] << endl;
}

//---------------------------
int main()
//---------------------------
{
	int a[10]{ 1,2,3,4,5 };
	vector<int> v{ 1,2,3,4,5 };
	// [문제] print는 a를 인자로 받아 전체 원소를 출력한다.
	// a를 선언과 정의하고 호출하라
	
	print(a);

	save("소스.cpp");
}

//----------------------------------------------------------<새로운 저장>-------------------------------------------------------
파일 이름 : 소스.cpp
파일크기:1147
2022-05-04 19:07:03 GMT+9

//------------------------------------<금일 강의 목표>----------------------------------
// 2022년 1학기 STL	5.4	수910목56 (9주 2일)
// 
// 1. Sequence container
// 2. Associative container
// 
// total ordering이란?
// <으로 같음을 판정  -> 상등(equivalence)
// ==으로 같음을 판정 -> 항등(quality)
// 
// 오늘 알아볼 것
//  - 제네릭 프로그래밍의 재미
//  - span : contiguous 컨테이너를 일관된 방식으로 다루기 위해 만든 view
//				T[], array<T, N>, vector<T>, string, STRING
// 
// 역방향 반복자와 삽입 반복자
// 
// 
//--------------------------------------------------------------------------------------

#include <iostream>
#include <vector>
#include <string>
#include <algorithm>

#include "save.h"
#include "STRING.h"

using namespace std;

void print(int[]);

void print(int a[])
{
	for (int i = 0; i < 10; ++i)
		cout << a[i] << endl;
}

//---------------------------
int main()
//---------------------------
{
	int a[10]{ 1,2,3,4,5 };
	vector<int> v{ 1,2,3,4,5 };
	// [문제] print는 a를 인자로 받아 전체 원소를 출력한다.
	// a를 선언과 정의하고 호출하라
	
	print(a);

	save("소스.cpp");
}

//----------------------------------------------------------<새로운 저장>-------------------------------------------------------
파일 이름 : 소스.cpp
파일크기:1731
2022-05-05 13:47:10 GMT+9

//------------------------------------<금일 강의 목표>----------------------------------
// 2022년 1학기 STL	5.5	수910목56 (10주 1일)
// 
// 1. Sequence container
// 2. Associative container
// 
// total ordering이란?
// <으로 같음을 판정  -> 상등(equivalence)
// ==으로 같음을 판정 -> 항등(quality)
// 
// 오늘 알아볼 것
//  - 제네릭 프로그래밍의 재미
//  - span : contiguous 컨테이너를 일관된 방식으로 다루기 위해 만든 view
//				T[], array<T, N>, vector<T>, string, STRING
// 
// 역방향 반복자와 삽입 반복자
// 
//--------------------------------------------------------------------------------------

#include <iostream>
#include <vector>
#include <span>	//c++20

#include "save.h"
#include "STRING.h"

using namespace std;

void print(span<int>);		// 배열을 함수의 인자로 사용하면 포인터로 바뀐다(type decay), int* == int[]

void print(span<int> a)
{
	cout << "span<int>이 차지한 메모리 크기 - " << a.size_bytes() << endl;
	for (int i = 0; i < a.size(); ++i)
		cout << a[i] << endl;
	cout << endl;
}

void print(span<char> a)
{
	cout << "span<char>이 차지한 메모리 크기 - " << a.size_bytes() << endl;
	for (int i = 0; i < a.size(); ++i)
		cout << a[i] << endl;
	cout << endl;
}

//---------------------------
int main()
//---------------------------
{
	int a[10]{ 1,2,3,4,5 };
	// int[10] -> span<int> 로 변환되어 전달된다.
	print(a);

	vector<int> v{ 1,3,5,7,9,11 };
	print(v);
	print(span<int>{v.begin() + 1, 3});	// 포인터와 갯수를 넘겨준다.

	STRING s{ "Standard Template Library" };
	print(span<char> {&(* s.begin()), s.getNum()});	// char포인터를 넘겨줘야 한다.

	//unique_ptr<int[]> p(new int[10]);
	//print(span<int>{p.get(), 10});

	save("소스.cpp");
}




//----------------------------------------------------------<새로운 저장>-------------------------------------------------------
파일 이름 : 소스.cpp
파일크기:1247
2022-05-05 14:35:41 GMT+9

//------------------------------------<금일 강의 목표>----------------------------------
// 2022년 1학기 STL	5.5	수910목56 (10주 1일)
// 
// 1. Sequence container
// 2. Associative container - set/multi_set/map/multi_map
// 
// 오늘 알아볼 것
// set = key를 compare로 정렬하고 있다. 찾기/제거/추가 동작이 O(log N)
// - set의 주요 동작을 알아본다.
// - set에 내가 만든 Dog를 넣어본다.
// 
//--------------------------------------------------------------------------------------

#include <iostream>
#include <set>
#include <vector>
#include <random>
#include <numeric>
#include <format>

#include "save.h"
#include "STRING.h"

using namespace std;

random_device rd;
default_random_engine dre{rd()};

//---------------------------
int main()
//---------------------------
{
	vector<int> v(100);	// ()를 쓰면 그만큼 크기를 잡고 0으로 초기화 해준다.
	iota(v.begin(), v.end(), 1);	// 값을 ++해주면서 채워준다.
	shuffle(v.begin(), v.end(), dre);

	for (int n : v)
		cout << format("{:4}", n);
	cout << endl;

	// [문제] v의 원소를 내림차순으로 정렬하는 set에 널고 출력한다.
	set<int, greater<int>> s{v.begin(), v.end()};

	for (int n : s)
		cout << format("{:4}", n);
	cout << endl;

	save("소스.cpp");
}

//----------------------------------------------------------<새로운 저장>-------------------------------------------------------
파일 이름 : 소스.cpp
파일크기:1014
2022-05-05 14:45:11 GMT+9

//---------------------------------<금일 강의 목표>----------------------------
// 2022년 1학기 STL	5.5	수910목56 (10주 1일)
// 
// 1. Sequence container
// 2. Associative container - set/multi_set/map/multi_map
// 
// 오늘 알아볼 것
// set = key를 compare로 정렬하고 있다. 찾기/제거/추가 동작이 O(log N)
// - set의 주요 동작을 알아본다.
// - set에 내가 만든 Dog를 넣어본다.
// 
//-----------------------------------------------------------------------------

#include <iostream>
#include <set>
#include <fstream>
#include <format>

#include "save.h"
#include "STRING.h"

using namespace std;

//---------------------------
int main()
//---------------------------
{

	// [문제] "소스.cpp"의 단어를 set에 저장하라.
	ifstream in{ "소스.cpp" };

	set<string> s(istream_iterator<string>{in}, {});	//multiset

	//역순으로 한 단어당 한 줄씩 화면 중앙에 출력하라.
	for (auto i = s.crbegin(); i != s.crend(); ++i)
		cout << format("{:^80}", *i);
	cout << endl;

	save("소스.cpp");
}

//----------------------------------------------------------<새로운 저장>-------------------------------------------------------
파일 이름 : 소스.cpp
파일크기:1272
2022-05-05 14:55:06 GMT+9

//---------------------------------<금일 강의 목표>----------------------------
// 2022년 1학기 STL	5.5	수910목56 (10주 1일)
// 
// 1. Sequence container
// 2. Associative container - set/multi_set/map/multi_map
// 
// 오늘 알아볼 것
// set = key를 compare로 정렬하고 있다. 찾기/제거/추가 동작이 O(log N)
// - set의 주요 동작을 알아본다.
// - set에 내가 만든 Dog를 넣어본다.
// 
//-----------------------------------------------------------------------------

#include <iostream>
#include <set>
#include <fstream>
#include <format>

#include "save.h"
#include "STRING.h"

using namespace std;

//---------------------------
int main()
//---------------------------
{
	save("소스.cpp");
	ifstream in{ "소스.cpp" };

	multiset<string> s(istream_iterator<string>{in}, {});	//multiset

	// 찾을 단어를 입력받아 있는지 없는지 알려준다.
	while (true) {
		cout << "찾을 단어는? ";
		string word;
		cin >> word;

		// [문제] 있나 없나 얼른 알려주자.
		auto p = s.find(word);
		if (p == s.end()) {
			cout << "없습니다." << endl;
		}
		else {
			cout << format("{:20} 라는 단어가 있습니다.\n", *p);
		}

	}

}

//----------------------------------------------------------<새로운 저장>-------------------------------------------------------
파일 이름 : 소스.cpp
파일크기:1207
2022-05-05 15:01:00 GMT+9

//---------------------------------<금일 강의 목표>----------------------------
// 2022년 1학기 STL	5.5	수910목56 (10주 1일)
// 
// 1. Sequence container
// 2. Associative container - set/multi_set/map/multi_map
// 
// 오늘 알아볼 것
// set = key를 compare로 정렬하고 있다. 찾기/제거/추가 동작이 O(log N)
// - set의 주요 동작을 알아본다.
// - set에 내가 만든 Dog를 넣어본다.
// 
//-----------------------------------------------------------------------------

#include <iostream>
#include <set>
#include <fstream>
#include <format>
#include <vector>

#include "save.h"
#include "STRING.h"

using namespace std;

//---------------------------
int main()
//---------------------------
{
	save("소스.cpp");
	ifstream in{ "소스.cpp" };

	multiset<string> s(istream_iterator<string>{in}, {});	//multiset

	for (auto i = s.crbegin(); i != s.crend(); ++i)
		cout << format("{:^80}", *i);
	cout << endl;

	// 찾을 단어를 입력받아 있는지 알려준다.
	while (true) {
		cout << "찾을 단어는? ";
		string word;
		cin >> word;

		// [문제] 있나 없나 얼른 알려주자. -> contains 함수로 해결
		cout << boolalpha << s.contains(word) << endl;	//c++20

	}

}

//----------------------------------------------------------<새로운 저장>-------------------------------------------------------
파일 이름 : 소스.cpp
파일크기:1344
2022-05-05 15:05:57 GMT+9

//---------------------------------<금일 강의 목표>----------------------------
// 2022년 1학기 STL	5.5	수910목56 (10주 1일)
// 
// 1. Sequence container
// 2. Associative container - set/multi_set/map/multi_map
// 
// 오늘 알아볼 것
// set = key를 compare로 정렬하고 있다. 찾기/제거/추가 동작이 O(log N)
// - set의 주요 동작을 알아본다.
// - set에 내가 만든 Dog를 넣어본다.
// 
//-----------------------------------------------------------------------------

#include <iostream>
#include <set>
#include <fstream>
#include <format>
#include <vector>

#include "save.h"
#include "STRING.h"

using namespace std;

//---------------------------
int main()
//---------------------------
{
	save("소스.cpp");
	ifstream in{ "소스.cpp" };

	multiset<string> s(istream_iterator<string>{in}, {});	//multiset

	for (auto i = s.crbegin(); i != s.crend(); ++i)
		cout << format("{:^80}", *i);
	cout << endl;

	// 찾을 단어를 입력받아 있는지 알려준다.
	while (true) {
		cout << "찾을 단어는? ";
		string word;
		cin >> word;

		// [문제] 구간을 찾는다
		auto [하한, 상한] = s.equal_range(word);	// structure-binding
		if (하한 == 상한)
			cout << word << " - 없는 단어 입니다." << endl;
		else {
			cout << word << " - " << distance(하한, 상한) << "개 있습니다." << endl;
		}

	}
}

//----------------------------------------------------------<새로운 저장>-------------------------------------------------------
파일 이름 : 소스.cpp
파일크기:1614
2022-05-05 15:25:10 GMT+9

//---------------------------------<금일 강의 목표>----------------------------
// 2022년 1학기 STL	5.5	수910목56 (10주 1일)
// 
// 1. Sequence container
// 2. Associative container - set/multi_set/map/multi_map
// 
// 오늘 알아볼 것
// set = key를 compare로 정렬하고 있다. 찾기/제거/추가 동작이 O(log N)
// - set의 주요 동작을 알아본다.
// - set에 내가 만든 Dog를 넣어본다.
// 
//-----------------------------------------------------------------------------

#include <iostream>
#include <set>
#include <string>
#include <random>
#include <list>

#include "save.h"
#include "STRING.h"

using namespace std;

default_random_engine dre;
uniform_int_distribution<int> uid{ 'a', 'z' };
uniform_int_distribution<int> uidNum{ 1, 10000 };

class Dog {
	string name;
	int num;

public:
	Dog() {
		for (int i = 0; i < 10; ++i)
			name += uid(dre);
		num = uidNum(dre);
	}

	bool operator<(const Dog& rhs) {
		return num < rhs.num;
	}

	void show() const {
		cout << name << " - " << num << endl;
	}

	string getName() const {
		return name;
	}

};

class 정렬가능한타입 {
public:
	bool operator()(const Dog& a, const Dog& b) const	// 한정자(const, volatile), const를 써서 set의 원소를 바꾸지 않겠다고 보장해줘야 한다. 
	{
		return a.getName() < b.getName();
	}
};

//---------------------------
int main()
//---------------------------
{
	set<Dog, 정렬가능한타입 > s;	//정렬가능한 타입

	// s에 Dog 1000개를 집어넣어라. - 이름 오름차순

	for (int i = 0; i < 1000; ++i)
		s.insert(Dog());

	for (const Dog& d : s)
		d.show();

	save("소스.cpp");
}

//----------------------------------------------------------<새로운 저장>-------------------------------------------------------
파일 이름 : 소스.cpp
파일크기:1937
2022-05-11 18:13:25 GMT+9

//---------------------------------<금일 강의 목표>----------------------------
// 2022년 1학기 STL	5.11	수910목56 (10주 2일)
// 
// 1. Sequence container - array/vector/deque/forwardList/list  + span(T[], array, vector, string 포장)
// 2. Associative container - set/multi_set/map/multi_map
// 3. Unordered Associative
// 
// c++20에서 위의 자료구조를 포장한것이 RANGE이다.
// 
// 오늘 알아볼 것
// set = key를 compare로 정렬하고 있다. 찾기/제거/추가 동작이 O(log N)
// - set의 주요 동작을 알아본다.
// - set에 내가 만든 Dog를 넣어본다.
// 
// 5/25(수) - 졸업연구설명회(2시30분?) 5/30~6/20 지도교수 찾아서 도장찍는 기간
// 
//-----------------------------------------------------------------------------

#include <iostream>
#include <set>
#include <string>
#include <random>
#include <list>

#include "save.h"
#include "STRING.h"

using namespace std;

default_random_engine dre;
uniform_int_distribution<int> uid{ 'a', 'z' };
uniform_int_distribution<int> uidNum{ 1, 10000 };

class Dog {
	string name;
	int num;

public:
	Dog() {
		for (int i = 0; i < 10; ++i)
			name += uid(dre);
		num = uidNum(dre);
	}

	bool operator<(const Dog& rhs) const {	//기본 정렬기준, const를 붙여줘야 작동한다.
		return num < rhs.num;
	}

	void show() const {
		cout << name << " - " << num << endl;
	}

	string getName() const {
		return name;
	}

	int getNum() const {
		return num;
	}

};

//---------------------------
int main()
//---------------------------
{
	set<Dog> s;

	for (int i = 0; i < 1000; ++i)
		s.emplace();	//인자를 넘겨줘서 객체를 집어넣을 수 있다. vs  s.insert(Dog());
	
	// Default일때 진행되는 상황 :
	// 1. less<Dog>이 있나 찾는다. (+표준에 Dog를 넣는건 합당하지 않다 : less<Dog>를 정의하는건 합당x)
	// 2. operator<(Dog, Dog)가 있나 찾는다.
	//	2-1 멤버함수로
	//	2-2 전역함수도 가능

	for (const Dog& dog : s)
		dog.show();

	save("소스.cpp");
}

//----------------------------------------------------------<새로운 저장>-------------------------------------------------------
파일 이름 : 소스.cpp
파일크기:2227
2022-05-11 18:19:09 GMT+9

//---------------------------------<금일 강의 목표>----------------------------
// 2022년 1학기 STL	5.11	수910목56 (10주 2일)
// 
// 1. Sequence container - array/vector/deque/forwardList/list  + span(T[], array, vector, string 포장)
// 2. Associative container - set/multi_set/map/multi_map
// 3. Unordered Associative
// 
// c++20에서 위의 자료구조를 포장한것이 RANGE이다.
// 
// 오늘 알아볼 것
// set = key를 compare로 정렬하고 있다. 찾기/제거/추가 동작이 O(log N)
// - set의 주요 동작을 알아본다.
// - set에 내가 만든 Dog를 넣어본다.
// 
// 5/25(수) - 졸업연구설명회(2시30분?) 5/30~6/20 지도교수 찾아서 도장찍는 기간
// 
//-----------------------------------------------------------------------------

#include <iostream>
#include <set>
#include <string>
#include <random>
#include <list>

#include "save.h"
#include "STRING.h"

using namespace std;

default_random_engine dre;
uniform_int_distribution<int> uid{ 'a', 'z' };
uniform_int_distribution<int> uidNum{ 1, 10000 };

class Dog {
	string name;
	int num;

public:
	Dog() {
		for (int i = 0; i < 10; ++i)
			name += uid(dre);
		num = uidNum(dre);
	}

	bool operator<(const Dog& rhs) const {	//기본 정렬기준, const를 붙여줘야 작동한다.
		return num < rhs.num;
	}

	void show() const {
		cout << name << " - " << num << endl;
	}

	string getName() const {
		return name;
	}

	int getNum() const {
		return num;
	}

};

//람다로 만드는 방법
auto 정렬기준 = [](const Dog& a, const Dog& b)
{
	return a.getName() < b.getName();
};

//---------------------------
int main()
//---------------------------
{
	//array<int, 10> 에서 10은 none-type arg 이다.

	set<Dog, decltype(정렬기준)> s;	// decltype : 선언시 너가 유추한 타입으로

	for (int i = 0; i < 1000; ++i)
		s.emplace();	//인자를 넘겨줘서 객체를 집어넣을 수 있다. vs  s.insert(Dog());
	
	// Default일때 진행되는 상황 :
	// 1. less<Dog>이 있나 찾는다. (+표준에 Dog를 넣는건 합당하지 않다 : less<Dog>를 정의하는건 합당x)
	// 2. operator<(Dog, Dog)가 있나 찾는다.
	//	2-1 멤버함수로
	//	2-2 전역함수도 가능
	// 3. 정렬기준을 직접 알려준다. 템플릿의 인자로 타입을 전달

	for (const Dog& dog : s)
		dog.show();

	save("소스.cpp");
}

//----------------------------------------------------------<새로운 저장>-------------------------------------------------------
파일 이름 : 소스.cpp
파일크기:2254
2022-05-11 18:21:13 GMT+9

//---------------------------------<금일 강의 목표>----------------------------
// 2022년 1학기 STL	5.11	수910목56 (10주 2일)
// 
// 1. Sequence container - array/vector/deque/forwardList/list  + span(T[], array, vector, string 포장)
// 2. Associative container - set/multi_set/map/multi_map
// 3. Unordered Associative
// 
// c++20에서 위의 자료구조를 포장한것이 RANGE이다.
// 
// 오늘 알아볼 것
// set = key를 compare로 정렬하고 있다. 찾기/제거/추가 동작이 O(log N)
// - set의 주요 동작을 알아본다.
// - set에 내가 만든 Dog를 넣어본다.
// 
// 5/25(수) - 졸업연구설명회(2시30분?) 5/30~6/20 지도교수 찾아서 도장찍는 기간
// 
//-----------------------------------------------------------------------------

#include <iostream>
#include <set>
#include <string>
#include <random>
#include <list>

#include "save.h"
#include "STRING.h"

using namespace std;

default_random_engine dre;
uniform_int_distribution<int> uid{ 'a', 'z' };
uniform_int_distribution<int> uidNum{ 1, 10000 };

class Dog {
	string name;
	int num;

public:
	Dog() {
		for (int i = 0; i < 10; ++i)
			name += uid(dre);
		num = uidNum(dre);
	}

	bool operator<(const Dog& rhs) const {	//기본 정렬기준, 멤버 함수가 될때는 const를 붙여줘야 작동한다.
		return num < rhs.num;
	}

	void show() const {
		cout << name << " - " << num << endl;
	}

	string getName() const {
		return name;
	}

	int getNum() const {
		return num;
	}

};

class 정렬기준 {
public:
	bool operator()(const Dog& a, const Dog& b) const
	{
		return a.getName() < b.getName();
	};
};


//---------------------------
int main()
//---------------------------
{
	//array<int, 10> 에서 10은 none-type arg 이다.

	set<Dog, 정렬기준> s;	// decltype : 선언시 너가 유추한 타입으로

	for (int i = 0; i < 1000; ++i)
		s.emplace();	//인자를 넘겨줘서 객체를 집어넣을 수 있다. vs  s.insert(Dog());
	
	// Default일때 진행되는 상황 :
	// 1. less<Dog>이 있나 찾는다. (+표준에 Dog를 넣는건 합당하지 않다 : less<Dog>를 정의하는건 합당x)
	// 2. operator<(Dog, Dog)가 있나 찾는다.
	//	2-1 멤버함수로
	//	2-2 전역함수도 가능
	// 3. 정렬기준을 직접 알려준다. 템플릿의 인자로 타입을 전달

	for (const Dog& dog : s)
		dog.show();

	save("소스.cpp");
}

//----------------------------------------------------------<새로운 저장>-------------------------------------------------------
파일 이름 : 소스.cpp
파일크기:1440
2022-05-11 18:39:57 GMT+9

//---------------------------------<금일 강의 목표>----------------------------
// 2022년 1학기 STL	5.11	수910목56 (10주 2일)
// 
// 1. Sequence container - array/vector/deque/forwardList/list  + span(T[], array, vector, string 포장)
// 2. Associative container - set/multi_set/map/multi_map
// 3. Unordered Associative
// 
// c++20에서 위의 자료구조를 포장한것이 RANGE이다.
// 
// 오늘 알아볼 것
// set = key를 compare로 정렬하고 있다. 찾기/제거/추가 동작이 O(log N)
// - set의 주요 동작을 알아본다.
// - set에 내가 만든 Dog를 넣어본다.
// 
// 5/25(수) - 졸업연구설명회(2시30분?) 5/30~6/20 지도교수 찾아서 도장찍는 기간
// 
//-----------------------------------------------------------------------------

#include <iostream>
#include <set>
#include <string>
#include <format>

#include "save.h"
#include "STRING.h"

using namespace std;

// [문제] 키보드 단어를 set<string>에 저장하라
// set<string>은 단어의 길이기준 오름차순으로 정렬한다.
// 저장된 단어를 출력하라

class 길이순 {
public:
	bool operator()(const string& a, const string& b) const {
		return a.length() < b.length();
	}

};

//---------------------------
int main()
//---------------------------
{
	set<string, 길이순> s{ istream_iterator<string>{cin}, {} };	//여기서 set은 길이가 같은 것들은 1개만 저장한다.
	//multiset

	for (const string& word : s) {
		cout << format("{:^80}", word) << endl;
	}

	save("소스.cpp");
}

//----------------------------------------------------------<새로운 저장>-------------------------------------------------------
파일 이름 : 소스.cpp
파일크기:1769
2022-05-12 13:32:50 GMT+9

//---------------------------------<금일 강의 목표>----------------------------
// 2022년 1학기 STL	5.12	수910목56 (11주 1일)
// 
// 1. Sequence container - array/vector/deque/forwardList/list  + span(T[], array, vector, string 포장)
// 2. Associative container - set/multi_set/map/multi_map
//		
//		map<key, value, key_compare>
// 
// 3. Unordered Associative
// 
// c++20에서 위의 자료구조를 포장한것이 RANGE이다.
// 
// 오늘 알아볼 것
// set = key를 compare로 정렬하고 있다. 찾기/제거/추가 동작이 O(log N)
// - set의 주요 동작을 알아본다.
// - set에 내가 만든 Dog를 넣어본다.
// 
// 5/25(수) - 졸업연구설명회(2시30분?) 5/30~6/20 지도교수 찾아서 도장찍는 기간
// 기말시험 - 6/15 STL (15주 1일)
//-----------------------------------------------------------------------------

#include <iostream>
#include <map>
#include <vector>
#include <string>

#include "save.h"
#include "STRING.h"

using namespace std;

// [문제] 게임회사와 게임들을 map으로 관리한다.

//---------------------------
int main()
//---------------------------
{
	save("소스.cpp");
	map<string, vector<string>> gameC{ {"넥슨", {"바람의 나라", "메이플스토리"}} };

	pair<string, vector<string>> p{ "엔씨", {"리니지"} };
	gameC.insert(p);

	gameC.insert(make_pair("펄어비스", vector<string>{"검은사막"}));

	// 리스트 전체 출력

	for (const auto& [회사, 게임들] : gameC) {	//간단하게 하는 법, 주의: const와 &를 항상 생각하자
		cout << 회사 << "  -  ";
		for (const auto& 게임 : 게임들)
			cout << 게임 << " ";
		cout << endl;
	}

	// 사용자가 입력한 회사의 게임을 출력한다.
	while (true) {
		cout << "찾을 회사는?";
		string company;
		cin >> company;

		// 있으면 출력
		// 없으면 없다고 출력
	}

	save("소스.cpp");
}

//----------------------------------------------------------<새로운 저장>-------------------------------------------------------
파일 이름 : 소스.cpp
파일크기:1413
2022-05-12 13:41:20 GMT+9

//---------------------------------<금일 강의 목표>----------------------------
// 2022년 1학기 STL	5.12	수910목56 (11주 1일)
// 
// 1. Sequence container - array/vector/deque/forwardList/list  + span(T[], array, vector, string 포장)
// 2. Associative container - set/multi_set/map/multi_map
//		
//		map<key, value, key_compare>
// 
// 3. Unordered Associative
// 
// c++20에서 위의 자료구조를 포장한것이 RANGE이다.
// 
// 오늘 알아볼 것
// set = key를 compare로 정렬하고 있다. 찾기/제거/추가 동작이 O(log N)
// - set의 주요 동작을 알아본다.
// - set에 내가 만든 Dog를 넣어본다.
// 
// 5/25(수) - 졸업연구설명회(2시30분?) 5/30~6/20 지도교수 찾아서 도장찍는 기간
// 기말시험 - 6/15 STL (15주 1일)
//-----------------------------------------------------------------------------

#include <iostream>
#include <map>
#include <vector>
#include <string>

#include "save.h"
#include "STRING.h"

using namespace std;

// [문제] 게임회사와 게임들을 map으로 관리한다.

//---------------------------
int main()
//---------------------------
{

	//연관배열처럼 사용할 수 있는 map
	// map<과일, 당도>
	map<string, double> sd;
	sd.insert( pair<string, double>{ "애플", 7 });
	sd.insert(make_pair("샤인머스켓", 12.5));
	
	sd["바나나"] = 9.3;	// sd.operator[]("바나나") = 9.3;
	
	for (const auto& [과일, 당도] : sd)
		cout << 과일 << " - " << 당도 << endl;

	save("소스.cpp");
}

//----------------------------------------------------------<새로운 저장>-------------------------------------------------------
파일 이름 : 소스.cpp
파일크기:1907
2022-05-12 14:10:31 GMT+9

//---------------------------------<금일 강의 목표>----------------------------
// 2022년 1학기 STL	5.12	수910목56 (11주 1일)
// 
// 1. Sequence container - array/vector/deque/forwardList/list  + span(T[], array, vector, string 포장)
// 2. Associative container - set/multi_set/map/multi_map
//		
//		map<key, value, key_compare>
// 
// 3. Unordered Associative
// 
// c++20에서 위의 자료구조를 포장한것이 RANGE이다.
// 
// 5/25(수) - 졸업연구설명회(2시30분?) 5/30~6/20 지도교수 찾아서 도장찍는 기간
// 기말시험 - 6/15 STL (15주 1일)
//-----------------------------------------------------------------------------

#include <iostream>
#include <map>
#include <vector>
#include <string>
#include <fstream>
#include <algorithm>

#include "save.h"
#include "STRING.h"

using namespace std;

// [문제] e-class에서 Frankenstein.txt를 다운받아
// vector<string>에 저장하라
// 모두 몇 단어인지 출력하라.

//---------------------------
int main()
//---------------------------
{
	ifstream in{ "Frankenstein.txt" };

	vector<string> v{ istream_iterator<string>{in}, {} };
	cout << v.size() << endl;

	// [문제] 알파벳과 개수를 화면에 출력하라
	// map<알파벳, 개수> 

	map<char, int> alphaNum;

	for (const string& 단어 : v)
		for (char 글자 : 단어)
			if(isalpha(글자))
				alphaNum[글자]++;

	//for (auto [글자, 개수] : alphaNum)
	//	cout << "[" << 글자 << "] - " << 개수 << endl;
	
	// [문제] 개수 내림차순으로 출력
	vector<pair<char, int>> temp(alphaNum.begin(), alphaNum.end());
	sort(temp.begin(), temp.end(), [](pair<char, int> a, pair<char, int> b) {	//auto로 써도됨
		return a.second > b.second;
		});

	for(auto [c, i] : temp)
		cout << "[" << c << "] - " << i << endl;

	save("소스.cpp");
}

//----------------------------------------------------------<새로운 저장>-------------------------------------------------------
파일 이름 : 소스.cpp
파일크기:1860
2022-05-12 14:17:20 GMT+9

//---------------------------------<금일 강의 목표>----------------------------
// 2022년 1학기 STL	5.12	수910목56 (11주 1일)
// 
// 1. Sequence container - array/vector/deque/forwardList/list  + span(T[], array, vector, string 포장)
// 2. Associative container - set/multi_set/map/multi_map
//		
//		map<key, value, key_compare>
// 
// 3. Unordered Associative
// 
// c++20에서 위의 자료구조를 포장한것이 RANGE이다.
// 
// 5/25(수) - 졸업연구설명회(2시30분?) 5/30~6/20 지도교수 찾아서 도장찍는 기간
// 기말시험 - 6/15 STL (15주 1일)
//-----------------------------------------------------------------------------

#include <iostream>
#include <map>
#include <vector>
#include <string>
#include <fstream>
#include <algorithm>

#include "save.h"
#include "STRING.h"

using namespace std;

// [문제] e-class에서 Frankenstein.txt를 다운받아
// vector<string>에 저장하라
// 모두 몇 단어인지 출력하라.

//---------------------------
int main()
//---------------------------
{
	ifstream in{ "Frankenstein.txt" };

	vector<string> v{ istream_iterator<string>{in}, {} };
	cout << v.size() << endl;

	// [문제] 알파벳과 개수를 화면에 출력하라
	// map<알파벳, 개수> 

	map<char, int> alphaNum;

	for (const string& 단어 : v)
		for (char 글자 : 단어)
			if(isalpha(글자))
				alphaNum[글자]++;

	//for (auto [글자, 개수] : alphaNum)
	//	cout << "[" << 글자 << "] - " << 개수 << endl;
	
	// [문제] 개수 내림차순으로 출력
	map<int, char, greater<int>> numAlpha;

	for (auto [글자, 개수] : alphaNum)
		numAlpha.insert({ 개수, 글자 });

	for (auto [개수, 글자] : numAlpha)
		cout << "[" << 글자 << "] - " << 개수 << endl;

	save("소스.cpp");
}

//----------------------------------------------------------<새로운 저장>-------------------------------------------------------
파일 이름 : 소스.cpp
파일크기:1539
2022-05-12 14:47:34 GMT+9

//---------------------------------<금일 강의 목표>----------------------------
// 2022년 1학기 STL	5.12	수910목56 (11주 1일)
// 
// 1. Sequence container - array/vector/deque/forwardList/list  + span(T[], array, vector, string 포장)
// 2. Associative container - set/multi_set/map/multi_map
//		
//		map<key, value, key_compare>
// 
// 3. Unordered Associative
// 
// c++20에서 위의 자료구조를 포장한것이 RANGE이다.
// 
// 
// 5/25(수) - 졸업연구설명회(2시30분?) 5/30~6/20 지도교수 찾아서 도장찍는 기간
// 기말시험 - 6/15 STL (15주 1일)
//-----------------------------------------------------------------------------

#include <iostream>
#include <map>
#include <vector>
#include <string>
#include <fstream>
#include <algorithm>

#include "save.h"
#include "STRING.h"

using namespace std;

// [문제] e-class에서 Frankenstein.txt를 다운받아
// vector<string>에 저장하라
// 모두 몇 단어인지 출력하라.

//---------------------------
int main()
//---------------------------
{
	ifstream in{ "Frankenstein.txt" };

	vector<string> v{ istream_iterator<string>{in}, {} };
	cout << v.size() << endl;

	// [문제] 길이가 11인 단어를 "길이11.txt"에 기록하라.
	ofstream out{ "길이11.txt" };

	copy_if(v.cbegin(), v.cend(), ostream_iterator<string>{out, "\n"}, [](const string& s) {
		return s.length() == 11;
		});

	save("소스.cpp");
}

//----------------------------------------------------------<새로운 저장>-------------------------------------------------------
파일 이름 : 소스.cpp
파일크기:2337
2022-05-12 15:11:03 GMT+9

//---------------------------------<금일 강의 목표>----------------------------
// 2022년 1학기 STL	5.12	수910목56 (11주 1일)
// 
// 1. Sequence container - array/vector/deque/forwardList/list  + span(T[], array, vector, string 포장)
// 2. Associative container - set/multi_set/map/multi_map
//		
//		map<key, value, key_compare>
// 
// 3. Unordered Associative
// 
// c++20에서 위의 자료구조를 포장한것이 RANGE이다.
// 
// 5/25(수) - 졸업연구설명회(2시30분?) 5/30~6/20 지도교수 찾아서 도장찍는 기간
// 기말시험 - 6/15 STL (15주 1일)
//-----------------------------------------------------------------------------

#include <iostream>
#include <map>
#include <vector>
#include <string>
#include <fstream>
#include <algorithm>

#include "save.h"
#include "STRING.h"

using namespace std;

// [문제] e-class에서 Frankenstein.txt를 다운받아
// vector<string>에 저장하라
// 모두 몇 단어인지 출력하라.

//---------------------------
int main()
//---------------------------
{
	ifstream in{ "Frankenstein.txt" };

	vector<string> v{ istream_iterator<string>{in}, {} };
	cout << v.size() << endl;

	// [문제] 이 소설에 사용된 단어와 개수를 출력하라.
	// 개수가 많은 것 부터 20개만
	// 앞에서 부터 20개만
	map<string, int> wordNum;

	for (const string& 단어 : v)
		++wordNum[단어];



	vector<pair<string, int>> temp{ wordNum.begin(), wordNum.end() };
	sort(temp.begin(), temp.end(), [](const auto& a, const auto& b) {
		return a.second > b.second;
		});

	auto p = temp.begin();
	for (int i = 0; i < 20; ++i, ++p)
		cout << p->first << " - " << p->second << endl;


	//////////////////////방법2////////////////////////
	cout << "\n\n\n";
	// 만약 map<int, string> 으로 선언해서 넣을 경우 개수가 같은 단어에 대해서 중복되기 때문에 저장되지 않는다. 
	// 따라서 multimap<int, string>을 써야한다.
	multimap<int, string, greater<int>> numWord;

	for (auto [단어, 개수] : wordNum)
		numWord.insert({ 개수, 단어 });	//multimap은 numWord[개수] = 단어; 를 사용할 수 없다!

	auto p2 = numWord.begin();
	for (int i = 0; i < 20; ++i, ++p2)
		cout << p2->second << " - " << p2->first << endl;

	save("소스.cpp");
}

//----------------------------------------------------------<새로운 저장>-------------------------------------------------------
파일 이름 : 소스.cpp
파일크기:1354
2022-05-18 17:38:57 GMT+9

//---------------------------------<금일 강의 목표>----------------------------
// 2022년 1학기 STL	5.18	수910목56 (11주 2일)
// 
// 1. Sequence container - array/vector/deque/forwardList/list  + span(T[], array, vector, string 포장)
// 2. Associative container - set/multi_set/map/multi_map
//		
//		map<key, value, key_compare>
// 
// 3. Unordered Associative - unordered_set/unordered_map
//		장점 : 이거 보다 빨리 찾기 어렵다. (검증해 본다.)
//		단점 : 
//		-순서없는 셋을 파헤쳐본다. - 화면에 메모리를 그림으로 출력
//		-내가 만든 STRING을 unordered_set<STRING>하고 싶다
// 
// 
// c++20에서 위의 자료구조를 포장한것이 RANGE이다.
// 
// 5/25(수) - 졸업연구설명회(2시30분?) 5/30~6/20 지도교수 찾아서 도장찍는 기간
// 기말시험 - 6/15 STL (15주 1일)
//-----------------------------------------------------------------------------

#include <iostream>
#include <unordered_set>
#include "save.h"
#include "STRING.h"

using namespace std;

//---------------------------
int main()
//---------------------------
{
	unordered_set<int> us{ 1,2,3,4 };

	for (int n : us)
		cout << n << " ";
	cout << endl;

	us.insert(-1);

	for (int n : us)
		cout << n << " ";
	cout << endl;

	save("소스.cpp");
}


//----------------------------------------------------------<새로운 저장>-------------------------------------------------------
파일 이름 : 소스.cpp
파일크기:1631
2022-05-18 18:00:44 GMT+9

//---------------------------------<금일 강의 목표>----------------------------
// 2022년 1학기 STL	5.18	수910목56 (11주 2일)
// 
// 1. Sequence container - array/vector/deque/forwardList/list  + span(T[], array, vector, string 포장)
// 2. Associative container - set/multi_set/map/multi_map
//		
//		map<key, value, key_compare>
// 
// 3. Unordered Associative - unordered_set/unordered_map
//		장점 : 이거 보다 빨리 찾기 어렵다. (검증해 본다.)
//		단점 : 
//		-순서없는 셋을 파헤쳐본다. - 화면에 메모리를 그림으로 출력
//		-내가 만든 STRING을 unordered_set<STRING>하고 싶다
// 
// 
// c++20에서 위의 자료구조를 포장한것이 RANGE이다.
// 
// 5/25(수) - 졸업연구설명회(2시30분?) 5/30~6/20 지도교수 찾아서 도장찍는 기간
// 기말시험 - 6/15 STL (15주 1일)
//-----------------------------------------------------------------------------

#include <iostream>
#include <unordered_set>
#include "save.h"
#include "STRING.h"

using namespace std;

//---------------------------
int main()
//---------------------------
{
	save("소스.cpp");
	unordered_set<int> us{ 1,2,3,4 };

	while (true) {
		// 현재 메모리를 화면에 출력
		for (int i{}; i < us.bucket_count(); ++i) {
			cout << "[" << i << "]";
			for (auto p = us.begin(i); p != us.end(i); ++p) {	// i번째 버킷을 의미한다.
				cout << " -> " << *p;
			}
			cout << endl;
		}

		// 새로운 원소 추가
		cout << "추가할 int는 ?";
		int num;
		cin >> num;
		us.insert(num);
		cout << endl << endl;
	}

}

//----------------------------------------------------------<새로운 저장>-------------------------------------------------------
파일 이름 : 소스.cpp
파일크기:2046
2022-05-18 18:22:50 GMT+9

//---------------------------------<금일 강의 목표>----------------------------
// 2022년 1학기 STL	5.18	수910목56 (11주 2일)
// 
// 1. Sequence container - array/vector/deque/forwardList/list  + span(T[], array, vector, string 포장)
// 2. Associative container - set/multi_set/map/multi_map
//		
//		map<key, value, key_compare>
// 
// 3. Unordered Associative - unordered_set/unordered_map
//		장점 : 이거 보다 빨리 찾기 어렵다. (검증해 본다.)
//		단점 : 
//		-순서없는 셋을 파헤쳐본다. - 화면에 메모리를 그림으로 출력
//		-내가 만든 STRING을 unordered_set<STRING>하고 싶다
// 
// 
// c++20에서 위의 자료구조를 포장한것이 RANGE이다.
// 
// 5/25(수) - 졸업연구설명회(2시30분?) 5/30~6/20 지도교수 찾아서 도장찍는 기간
// 기말시험 - 6/15 STL (15주 1일)
//-----------------------------------------------------------------------------

#include <iostream>
#include <unordered_set>
#include "save.h"
#include "STRING.h"

using namespace std;

template<>
class hash<STRING> {	// 템플릿을 specialization 하는것 (템플릿으로 제너럴(일반화)한것 중에 특별이 이 타입에 대해 따로 선언한것 )
public:
	size_t operator()(const STRING& str) const {
		auto val = hash<string>()({ str.begin(), str.end() });	// 나를 잘 알려진 string타입으로 바꿔 넘겨준다.
		cout << "해시의 출력값 - " << val << "위치 - " << val % 8 << endl;
		return val;
	};
};

//---------------------------
int main()
//---------------------------
{
	save("소스.cpp");

	unordered_set<STRING, hash<STRING>> us{ "Standard", "Template", "Library"};	// hash에 callable 클래스를 넘겨줘야한다. operator는 안, hash<STINRG> 빼도됨

	while (true) {
		// 현재 메모리를 화면에 출력
		for (int i{}; i < us.bucket_count(); ++i) {
			cout << "[" << i << "]";
			for (auto p = us.begin(i); p != us.end(i); ++p) {	// i번째 버킷을 의미한다.
				cout << " -> " << *p;
			}
			cout << endl;
		}

		// 새로운 원소 추가
		cout << "추가할 STRING는 ?";
		STRING str;
		cin >> str;
		us.insert(str);
		cout << endl << endl;
	}

	//save("소스.cpp");
}

//----------------------------------------------------------<새로운 저장>-------------------------------------------------------
파일 이름 : 소스.cpp
파일크기:4571
2022-05-18 18:58:52 GMT+9

//---------------------------------<금일 강의 목표>----------------------------
// 2022년 1학기 STL	5.18	수910목56 (11주 2일)
// 
// 1. Sequence container - array/vector/deque/forwardList/list  + span(T[], array, vector, string 포장)
// 2. Associative container - set/multi_set/map/multi_map
//		
//		map<key, value, key_compare>
// 
// 3. Unordered Associative - unordered_set/unordered_map
//		장점 : 이거 보다 빨리 찾기 어렵다. (검증해 본다.)
//		단점 : 
//		-순서없는 셋을 파헤쳐본다. - 화면에 메모리를 그림으로 출력
//		-내가 만든 STRING을 unordered_set<STRING>하고 싶다
// 
// 컨테이너들의 찾기 실력을 검증해 본다.
// vector - set - unordered_set
//	O(n)	O(log n)	O(1)
// 1000만개 int 중에서 1000개의 int를 찾아본다.
// 
// c++20에서 위의 자료구조를 포장한것이 RANGE이다.
// 
// 5/25(수) - 졸업연구설명회(2시30분?) 5/30~6/20 지도교수 찾아서 도장찍는 기간
// 기말시험 - 6/15 STL (15주 1일)
//-----------------------------------------------------------------------------

#include <iostream>
#include <array>
#include <vector>
#include <set>
#include <unordered_set>
#include <random>
#include <algorithm>
#include <chrono>
#include "save.h"
#include "STRING.h"

using namespace std;

array<int, 1000'0000> numbers;
array<int, 1000> toFind;

default_random_engine dre;
uniform_int_distribution uid{ 1, 1'0000'0000 };

//---------------------------
int main()
//---------------------------
{
	for (int& n : numbers)
		n = uid(dre);

	for (int& n : toFind)
		n = uid(dre);

	{	// 벡터의 찾기 실력
		auto start1 = chrono::steady_clock::now();
		vector<int> v{ numbers.begin(), numbers.end() };
		auto stop1 = chrono::steady_clock::now();
		auto et1 = chrono::duration_cast<chrono::microseconds>(stop1 - start1).count();
		cout << "삽입 시간 - " << et1 << " us" << endl;
		cout << "벡터의 원소 개수 - " << v.size() << endl;
		cout << "찾을 int의 개수  - " << toFind.size() << endl;

		int cnt = 0;

		//스톱워치 누름
		auto start = chrono::steady_clock::now();

		for (int n : toFind) {
			auto p = find(v.begin(), v.end(), n);	//반환값을 안쓰면 컴파일단계에서 무시해 버린다(만들지 않는다).
			if (p != v.end())
				cnt++;
		}
		//스톱워치 다시 누름
		auto stop = chrono::steady_clock::now();
		auto et = chrono::duration_cast<chrono::microseconds>(stop - start).count();	// duration_cast<> : 사람이 알아볼 수 있는 경과시간으로 바꿔줌

		
		cout << "벡터에서 찾은 수 - " << cnt << endl;
		cout << "<<< 걸린시간 >>> - " << et << " us(마이크로 세컨드) " << endl << endl;
	}

	{	// 정렬된 벡터의 찾기 실력
		auto start1 = chrono::steady_clock::now();
		vector<int> v{ numbers.begin(), numbers.end() };
		sort(v.begin(), v.end());
		auto stop1 = chrono::steady_clock::now();
		auto et1 = chrono::duration_cast<chrono::microseconds>(stop1 - start1).count();
		cout << "삽입 시간 - " << et1 << " us" << endl;
		cout << "정렬된 벡터의 원소 개수 - " << v.size() << endl;
		cout << "찾을 int의 개수  - " << toFind.size() << endl;

		int cnt = 0;

		//스톱워치 누름
		auto start = chrono::steady_clock::now();

		for (int n : toFind) {
			if (binary_search(v.begin(), v.end(), n))
				cnt++;
		}
		//스톱워치 다시 누름
		auto stop = chrono::steady_clock::now();
		auto et = chrono::duration_cast<chrono::microseconds>(stop - start).count();	// duration_cast<> : 사람이 알아볼 수 있는 경과시간으로 바꿔줌


		cout << "정렬된 벡터에서 찾은 수 - " << cnt << endl;
		cout << "<<< 걸린시간 >>> - " << et << " us(마이크로 세컨드) " << endl << endl;
	}

	{	// 셋의 찾기 실력
		auto start1 = chrono::steady_clock::now();
		multiset<int> v{ numbers.begin(), numbers.end() };
		auto stop1 = chrono::steady_clock::now();
		auto et1 = chrono::duration_cast<chrono::microseconds>(stop1 - start1).count();
		cout << "삽입 시간 - " << et1 << " us" << endl;
		cout << "셋의 원소 개수 - " << v.size() << endl;
		cout << "찾을 int의 개수  - " << toFind.size() << endl;

		int cnt = 0;

		//스톱워치 누름
		auto start = chrono::steady_clock::now();

		for (int n : toFind) {
			if(v.contains(n))	//반환값을 안쓰면 컴파일단계에서 무시해 버린다(만들지 않는다).
				cnt++;
		}
		//스톱워치 다시 누름
		auto stop = chrono::steady_clock::now();
		auto et = chrono::duration_cast<chrono::microseconds>(stop - start).count();	// duration_cast<> : 사람이 알아볼 수 있는 경과시간으로 바꿔줌

		
		cout << "셋에서 찾은 수 - " << cnt << endl;
		cout << "<<< 걸린시간 >>> - " << et << " us(마이크로 세컨드) " << endl << endl;

	}

	{	// 언오더드셋의 찾기 실력
		auto start1 = chrono::steady_clock::now();
		unordered_multiset<int> v{ numbers.begin(), numbers.end() };
		auto stop1 = chrono::steady_clock::now();
		auto et1 = chrono::duration_cast<chrono::microseconds>(stop1 - start1).count();
		cout << "삽입 시간 - " << et1 << " us" << endl;
		cout << "언오더드셋의 원소 개수 - " << v.size() << endl;
		cout << "찾을 int의 개수  - " << toFind.size() << endl;

		int cnt = 0;

		//스톱워치 누름
		auto start = chrono::steady_clock::now();

		for (int n : toFind) {
			if (v.contains(n))	//반환값을 안쓰면 컴파일단계에서 무시해 버린다(만들지 않는다).
				cnt++;
		}
		//스톱워치 다시 누름
		auto stop = chrono::steady_clock::now();
		auto et = chrono::duration_cast<chrono::microseconds>(stop - start).count();	// duration_cast<> : 사람이 알아볼 수 있는 경과시간으로 바꿔줌


		cout << "언오더드셋에서 찾은 수 - " << cnt << endl;
		cout << "<<< 걸린시간 >>> - " << et << " us(마이크로 세컨드) " << endl << endl;

	}

	save("소스.cpp");
}

//----------------------------------------------------------<새로운 저장>-------------------------------------------------------
파일 이름 : 소스.cpp
파일크기:993
2022-05-19 14:37:14 GMT+9

//---------------------------------<금일 강의 목표>----------------------------
// 2022년 1학기 STL	5.19	수910목56 (12주 1일)
// 
// constexpr : 컴파일단계에 답이 정해짐
//-----------------------------------------------------------------------------

#include <iostream>
#include <vector>
#include <algorithm>
#include "save.h"
#include "STRING.h"

using namespace std;

template<class 구간, class 인수한개로판단>
bool allof(구간 시작, 구간 끝, 인수한개로판단 판단자) {
	while (시작 != 끝) {
		if (!판단자(*시작))
			return false;
		++시작;
	}
	return true;
}

//---------------------------
int main()
//---------------------------
{
	vector<STRING> v {"Standard", "Template", "Library"};

	// [문제] v에 있는 원소가 전부 5글자 이상인가?
	auto result = allof(v.begin(), v.end(), [](const STRING& s) {
		return 5 <= s.getNum();
		});

	if (result) {
		cout << "네 모두 5글자 이상입니다.\n";
	}
	else {
		cout << "아닙니다.\n";
	}

	save("소스.cpp");
}

//----------------------------------------------------------<새로운 저장>-------------------------------------------------------
파일 이름 : 소스.cpp
파일크기:878
2022-05-19 14:51:57 GMT+9

//---------------------------------<금일 강의 목표>----------------------------
// 2022년 1학기 STL	5.19	수910목56 (12주 1일)
// 
// constexpr : 컴파일단계에 답이 정해짐
//-----------------------------------------------------------------------------

#include <iostream>
#include <string>
#include <format>
#include <thread>
#include "save.h"
#include "STRING.h"

using namespace std;

//---------------------------
int main()
//---------------------------
{

	save("소스.cpp");
	string str{ "Google’s Russian branch plans to file for bankruptcy " };

	// [문제] str을 전광판처럼 계속 흘러가게 출력하라.
	for (int i = 0; i < 10; ++i) {
		cout << endl;
	}

	while (true) {
		cout << format("{:^78}", str) << "\r";
		this_thread::sleep_for(100ms);
		// 한 칸 왹쪽으로
		rotate(str.begin(), str.end() - 1, str.end());
	}

	//save("소스.cpp");
}

//----------------------------------------------------------<새로운 저장>-------------------------------------------------------
파일 이름 : 소스.cpp
파일크기:753
2022-05-19 15:01:57 GMT+9

//---------------------------------<금일 강의 목표>----------------------------
// 2022년 1학기 STL	5.19	수910목56 (12주 1일)
// 
// constexpr : 컴파일단계에 답이 정해짐
//-----------------------------------------------------------------------------

#include <iostream>
#include <string>
#include "save.h"
#include "STRING.h"

using namespace std;

//---------------------------
int main()
//---------------------------
{
	string s1{"abcdefghi"};	//abcd
	string s2{"abcdefhij"};

	auto[s1의다른위치, s2의다른위치] =  mismatch(s1.begin(), s1.end(), s2.begin());

	string s3{ s1의다른위치, s1.end() };
	string s4{ s2의다른위치, s2.end() };
	cout << s3 << " " << s4;


	save("소스.cpp");
}

//----------------------------------------------------------<새로운 저장>-------------------------------------------------------
파일 이름 : 소스.cpp
파일크기:870
2022-05-19 15:10:27 GMT+9

//---------------------------------<금일 강의 목표>----------------------------
// 2022년 1학기 STL	5.19	수910목56 (12주 1일)
// 
// constexpr : 컴파일단계에 답이 정해짐
// 
// find -> value나, 조건에 맞는 원소가 있는지 찾을때
// search -> 원소의 집합을 찾는다.
// serach_n
// 
// remove
// 
//-----------------------------------------------------------------------------

#include <iostream>
#include <vector>
#include "save.h"
#include "STRING.h"

using namespace std;

//---------------------------
int main()
//---------------------------
{
	vector<int> v{ 1,2,3,4,5,6,7,8,9,10 };

	// v에서 짝수를 제거하라.
	v.erase(remove_if(v.begin(), v.end(), [](int n) {
		return !(n % 2);
		}), v.end());

	//erase_if(v, [](int n) {
	//	return !(n % 2);
	//	});

	for (int n : v)
		cout << n << " ";
	cout << endl;

	save("소스.cpp");
}

//----------------------------------------------------------<새로운 저장>-------------------------------------------------------
파일 이름 : 소스.cpp
파일크기:920
2022-05-19 15:19:54 GMT+9

//---------------------------------<금일 강의 목표>----------------------------
// 2022년 1학기 STL	5.19	수910목56 (12주 1일)
// 
// constexpr : 컴파일단계에 답이 정해짐
// 
// find -> value나, 조건에 맞는 원소가 있는지 찾을때
// search -> 원소의 집합을 찾는다.
// serach_n
// 
// remove
// 
//-----------------------------------------------------------------------------

#include <iostream>
#include <vector>
#include <array>
#include <numeric>
#include <random>

#include "save.h"
#include "STRING.h"

using namespace std;

random_device rd;
default_random_engine dre{rd()};

//---------------------------
int main()
//---------------------------
{
	// lotto
	// sample

	vector<int> v(45);
	iota(v.begin(), v.end(), 1);

	array<int, 6> balls;
	sample(v.begin(), v.end(), balls.begin(), 6, dre);
	for (int n : balls)
		cout << n << " ";
	cout << endl;

	save("소스.cpp");
}

//----------------------------------------------------------<새로운 저장>-------------------------------------------------------
파일 이름 : 소스.cpp
파일크기:1156
2022-05-25 17:47:52 GMT+9

//---------------------------------<금일 강의 목표>----------------------------
// 2022년 1학기 STL	5.25	수910목56 (12주 2일)
// 
// constexpr : 컴파일단계에 답이 정해짐
// 
// find -> value나, 조건에 맞는 원소가 있는지 찾을때
// search -> 원소의 집합을 찾는다.
// serach_n
// 
// remove
// 
// 6/15(수) (15주 1일) - 기말시험
// 6/16(목) (15주 2일) - 강의 끝
// 
//-----------------------------------------------------------------------------

#include <iostream>
#include <vector>
#include <array>
#include <numeric>
#include <random>

#include "save.h"
#include "STRING.h"

using namespace std;

random_device rd;
default_random_engine dre{rd()};

template<class InIter, class OutIter>
void my_copy(InIter b, InIter e, OutIter o) 
{
	while (b != e) {
		*o = *b;
		++b;
		++o;
	}
}

//---------------------------
int main()
//---------------------------
{
	// copy는 왜 mutating 알고리즘으로 분류하나?,			copy(v.begin(), v.end(), v.begin() + 2); 를 한번 생각해보자
	vector v{ 1,2,3,4,5 };
	copy(v.begin(), v.end(), inserter(v, v.begin() + 2));

	for (int a : v)
		cout << a << " ";

	save("소스.cpp");
}

//----------------------------------------------------------<새로운 저장>-------------------------------------------------------
파일 이름 : 소스.cpp
파일크기:1172
2022-05-25 17:51:55 GMT+9

//---------------------------------<금일 강의 목표>----------------------------
// 2022년 1학기 STL	5.25	수910목56 (12주 2일)
// 
// constexpr : 컴파일단계에 답이 정해짐
// 
// find -> value나, 조건에 맞는 원소가 있는지 찾을때
// search -> 원소의 집합을 찾는다.
// serach_n
// 
// remove
// 
// 6/15(수) (15주 1일) - 기말시험
// 6/16(목) (15주 2일) - 강의 끝
// 
//-----------------------------------------------------------------------------

#include <iostream>
#include <vector>
#include <array>
#include <numeric>
#include <random>

#include "save.h"
#include "STRING.h"

using namespace std;

random_device rd;
default_random_engine dre{rd()};

template<class InIter, class OutIter>
void my_copy(InIter b, InIter e, OutIter o) 
{
	while (b != e) {
		*o = *b;
		++b;
		++o;
	}
}

//---------------------------
int main()
//---------------------------
{
	// unique - "옆에" 있는 중복된 값을 제거
	vector v{ 1,2,3,3,3,4,5,5,3 };
		// v{ 1,2,3,4,5,3,5,5,3 }	가 될 것이다. 쓰레기 값이 뒤쪽으로 이동
	v.erase(unique(v.begin(), v.end()), v.end());

	for (int n : v)
		cout << n << " ";
	cout << endl;

	save("소스.cpp");
}

//----------------------------------------------------------<새로운 저장>-------------------------------------------------------
파일 이름 : 소스.cpp
파일크기:1007
2022-05-25 18:01:18 GMT+9

//---------------------------------<금일 강의 목표>----------------------------
// 2022년 1학기 STL	5.25	수910목56 (12주 2일)
// 
// constexpr : 컴파일단계에 답이 정해짐
// 
// find -> value나, 조건에 맞는 원소가 있는지 찾을때
// search -> 원소의 집합을 찾는다.
// serach_n
// 
// remove
// 
// 6/15(수) (15주 1일) - 기말시험
// 6/16(목) (15주 2일) - 강의 끝
// 
//-----------------------------------------------------------------------------

#include <iostream>
#include <fstream>
#include <algorithm>
#include <vector>
#include <string>

#include "save.h"
#include "STRING.h"

using namespace std;

//---------------------------
int main()
//---------------------------
{
	// [문제] Frankenstein.txt에 사용된 단어 가짓수는 ?
	ifstream in{ "Frankenstein.txt" };
	vector<string> v{ istream_iterator<string>{in}, {} };
	sort(v.begin(), v.end());
	v.erase(unique(v.begin(), v.end()), v.end());

	cout << "사용된 단어 종류 - " << v.size() << endl;

	save("소스.cpp");
}

//----------------------------------------------------------<새로운 저장>-------------------------------------------------------
파일 이름 : 소스.cpp
파일크기:2737
2022-05-25 18:46:08 GMT+9

//---------------------------------<금일 강의 목표>----------------------------
// 2022년 1학기 STL	5.25	수910목56 (12주 2일)
// 
// 분리와 정렬 - Complexity 가 커지는 순서로 나열
// 1. partition : (앞쪽과 뒤쪽)두개의 부분으로 원소를 나누는 함수, ture부분의 end()를 반환한다.
// 2. nth_element
// 3. partial_sort
// 4. sort - Nlog(N)
// 5. stable_sort - Nlog(N*N)
// 
// 6/15(수) (15주 1일) - 기말시험
// 6/16(목) (15주 2일) - 강의 끝
// 
//-----------------------------------------------------------------------------

#include <iostream>
#include <algorithm>
#include <vector>
#include <numeric>
#include <format>
#include <random>

#include "save.h"
#include "STRING.h"

using namespace std;

random_device rd;
default_random_engine dre{};

template<class T>
void print(T b, T e) 
{
	while (b != e) {
		cout << format("{0:4d}", *b);
		++b;
	}
	cout << endl << endl;
}

//---------------------------
int main()
//---------------------------
{
	// 데이터 준비
	vector<int> v(100);	// int{}를 100번 호출
	iota(v.begin(), v.end(), 1);
	cout << "vector<int>의 값들 : " << endl;
	print(v.begin(), v.end());

	{	// 기준에 따라 분리
		shuffle(v.begin(), v.end(), dre);
		cout << "partition 이전" << endl;
		print(v.begin(), v.end());

		// [문제] 홀짝으로 분리하시오
		auto p = partition(v.begin(), v.end(), [](int n) {
			return n & 1;;
			});

		cout << "partition 이후" << endl;
		cout << "홀수" << endl;
		print(v.begin(), p);
		cout << "짝수" << endl;
		print(p, v.end());
	}

	{	// 선착순 50등 까지만 통과 - 1등 부터 50등까지 순서는 상관없다.
		shuffle(v.begin(), v.end(), dre);
		cout << "nth_element 이전" << endl;
		print(v.begin(), v.end());

		// [문제] 50등 까지만 통과시켜라
		nth_element(v.begin(), v.begin() + 50, v.end());	// 이미 내가 기준선을 주고 호출했기 때문에 리턴값이 없다.
		cout << "기준선 통과" << endl;
		print(v.begin(), v.begin() + 50);	// 정렬과는 무관한다!!. + 마지막 순위가 여러개 일경우 아무거나 뽑는다.
		cout << "통과 못함" << endl;
		print(v.begin() + 50, v.end());

	}

	{	// 1등부터 50등까지는 정렬 - 나머지는 상관없다.
		shuffle(v.begin(), v.end(), dre);
		cout << "partial_sort 이전" << endl;
		print(v.begin(), v.end());

		// [문제] 50등까지만 정렬하라
		partial_sort(v.begin(), v.begin() + 50, v.end());
		cout << "50등까지 정렬" << endl;
		print(v.begin(), v.begin() + 50);
		cout << "나머지" << endl;
		print(v.begin() + 50, v.end());

	}

	{	// 전체 정렬
		shuffle(v.begin(), v.end(), dre);
		cout << "sort 이전" << endl;
		print(v.begin(), v.end());

		// [문제] 정렬하라
		sort(v.begin(), v.end());
		cout << "sort 이후" << endl;
		print(v.begin(), v.end());

	}


	save("소스.cpp");
}

//----------------------------------------------------------<새로운 저장>-------------------------------------------------------
파일 이름 : 소스.cpp
파일크기:1732
2022-05-26 14:19:14 GMT+9

//---------------------------------<금일 강의 목표>----------------------------
// 2022년 1학기 STL	5.26	수910목56 (13주 1일)
// 
// C++20의 핵심
// concepts
// range/view
//		coroutine
//		module - 확장자 ixx, : 아직 쓰기는 멀었다.
// 
// Metaprogramming library : 컴파일 단계에 물어볼 수 있다.
// type traits - Metaprogramming의 도구, is_ 시리즈, 
// 
// 6/15(수) (15주 1일) - 기말시험
// 6/16(목) (15주 2일) - 강의 끝
// 
//-----------------------------------------------------------------------------

#include <iostream>
#include <vector>
#include <list>
#include <forward_list>

#include "save.h"
#include "STRING.h"

using namespace std;

// 제네릭이기 때문에 iter의 거리를 재기 위한 함수지만 int 형을 매개변수로 전달받아도 실행이 된다.
template<class Iter>
ptrdiff_t dist(Iter s, Iter e)
{
	// Iter가 반복자인지 판정한다.
	// Iter가 input_iterator_tag를 상속했나 판단.

	// is_base_of와 같은 퀘리에 _v를 붙이면 true나 false를 반환해주는 버전이 된다.
	// iterator의 특성중 카테고리를 꺼내서 비교하도록 해준다.
	// typename을 붙여 타입임을 명시해준다.
	if (is_base_of_v<input_iterator_tag, typename iterator_traits<Iter>::iterator_category> )	
		cout << "반복자가 맞다." << endl;
	else
		cout << "반복자가 아니다." << endl;
	return 1;
}

class Dog {

};

//---------------------------
int main()
//---------------------------
{
	// 반복자간의 거리를 계산하는 distance 함수
	// -> concept -> range -> 
	
	vector<int> v{ 1,2,3,4,5 };

	// distance에 list를 역방향으로 매개변수를 주면 잘못된 값이 나온다.
	// forward_list의 경우 프로그램이 죽는다.

	// 템플릿 함수 dist를 작성하라
	cout << dist(v.begin(), v.end()) << endl;

	//dist(1, 100);

	save("소스.cpp");
}

//----------------------------------------------------------<새로운 저장>-------------------------------------------------------
파일 이름 : 소스.cpp
파일크기:1144
2022-05-26 14:28:25 GMT+9

//---------------------------------<금일 강의 목표>----------------------------
// 2022년 1학기 STL	5.26	수910목56 (13주 1일)
// 
// C++20의 핵심
// concepts
// range/view
//		coroutine
//		module - 확장자 ixx, : 아직 쓰기는 멀었다.
// 
// Metaprogramming library : 컴파일 단계에 물어볼 수 있다.
// type traits - Metaprogramming의 도구, is_ 시리즈, 
// 
// 6/15(수) (15주 1일) - 기말시험
// 6/16(목) (15주 2일) - 강의 끝
// 
//-----------------------------------------------------------------------------

#include <iostream>
#include <vector>
#include <deque>
#include <concepts>

#include "save.h"
#include "STRING.h"

using namespace std;

template<contiguous_iterator Iter>	// class 대신에 contiguous_iterator를 적음,  아예 타입을 "제약"하는 방법(concept)
void cf(Iter b, Iter e) 
{
	cout << "contigous 메모리" << endl;
}

//---------------------------
int main()
//---------------------------
{
	// contiguous한 메모리에서만 작업하는 cf 함수
	vector<int> v;
	deque<int> d;

	cf(v.begin(), v.end());	// contiguous 맞다.
	//cf(d.begin(), d.end());	// random-access라 아니다.

	//STRING s;
	//cf(s.begin(), s.end());	// 이것도 카테고리를 random으로 해놔서 실행안됨

	save("소스.cpp");
}

//----------------------------------------------------------<새로운 저장>-------------------------------------------------------
파일 이름 : 소스.cpp
파일크기:1848
2022-05-26 15:09:13 GMT+9

//---------------------------------<금일 강의 목표>----------------------------
// 2022년 1학기 STL	5.26	수910목56 (13주 1일)
// 
// C++20의 핵심
// concepts
// range/view
//		coroutine
//		module - 확장자 ixx, : 아직 쓰기는 멀었다.
// 
// Metaprogramming library : 컴파일 단계에 물어볼 수 있다.
// type traits - Metaprogramming의 도구, is_ 시리즈, 
// 
// 6/15(수) (15주 1일) - 기말시험
// 6/16(목) (15주 2일) - 강의 끝
// 
//-----------------------------------------------------------------------------

#include <iostream>
#include <vector>
#include <list>
#include <deque>
#include <concepts>	// concepts : 만족해야 하는 조건, 예) https://en.cppreference.com/w/cpp/iterator/random_access_iterator

#include "save.h"
#include "STRING.h"

using namespace std;

template<input_iterator Iter>
long long dist(Iter b, Iter e) 
{
	// 만일 random_access 반복자라면 -로 계산
	if constexpr (is_same_v<typename iterator_traits<Iter>::iterator_category, random_access_iterator_tag>) {
		cout << " -로 계산 " << endl;
		return e - b;
	}

	// 아니라면 
	// (이 코드만 남으면 좋은데 list 반복자가 전달될때 위의 e-b 코드도 생성된다.)
	// --> list 반복자가 - 연산을 지원하지 않기 때문에 compile 오류
	// C++17이전 - tag dispatching으로 해결한다.
	// C++17이후 - constexpr if (선택적 코드생성)로 해결가능
	else {
		long long step = 0;
		while (b != e) {
			++step;
			++b;
		}
		cout << "한 걸음씩 세서 계산" << endl;
		return step;
	}

}

//---------------------------
int main()
//---------------------------
{
	//표준 dist를 구현한다.
	vector<int> v{ 1,2,3 };

	cout << dist(v.begin(), v.end()) << endl;
	//dist(1, 100);	//제약 조건 만족 실패

	list<int> lst;
	cout << dist(lst.end(), lst.begin()) << endl;

	//STRING s{ "asd" };
	//cout << dist(s.begin(), s.end());	// concept이 만족하지 않아서 실행안됨

	save("소스.cpp");
}

//----------------------------------------------------------<새로운 저장>-------------------------------------------------------
파일 이름 : 소스.cpp
파일크기:1916
2022-05-26 15:15:07 GMT+9

//---------------------------------<금일 강의 목표>----------------------------
// 2022년 1학기 STL	5.26	수910목56 (13주 1일)
// 
// C++20의 핵심
// concepts
// range/view
//		coroutine
//		module - 확장자 ixx, : 아직 쓰기는 멀었다.
// 
// Metaprogramming library : 컴파일 단계에 물어볼 수 있다.
// type traits - Metaprogramming의 도구, is_ 시리즈, 
// 
// 6/15(수) (15주 1일) - 기말시험
// 6/16(목) (15주 2일) - 강의 끝
// 
//-----------------------------------------------------------------------------

#include <iostream>
#include <vector>
#include <list>
#include <deque>
#include <algorithm>
#include <concepts>	// concepts : 만족해야 하는 조건, 예) https://en.cppreference.com/w/cpp/iterator/random_access_iterator
#include <ranges> //range는 컨셉이 붙은 함수들이다. (기존 함수는 이전 버전과 호환을 위해 컨셉을 넣지 않았다.)

#include "save.h"
#include "STRING.h"

using namespace std;

template<input_iterator Iter>
long long dist(Iter b, Iter e) 
{
	// 만일 random_access 반복자라면 -로 계산
	if constexpr (is_same_v<typename iterator_traits<Iter>::iterator_category, random_access_iterator_tag>) {
		cout << " -로 계산 " << endl;
		return e - b;
	}

	// 아니라면 
	// (이 코드만 남으면 좋은데 list 반복자가 전달될때 위의 e-b 코드도 생성된다.)
	// --> list 반복자가 - 연산을 지원하지 않기 때문에 compile 오류
	// C++17이전 - tag dispatching으로 해결한다.
	// C++17이후 - constexpr if (선택적 코드생성)로 해결가능
	else {
		long long step = 0;
		while (b != e) {
			++step;
			++b;
		}
		cout << "한 걸음씩 세서 계산" << endl;
		return step;
	}

}

//---------------------------
int main()
//---------------------------
{
	list<int> lst;
	//sort(lst.end(), lst.begin());	// 실행기키면 오류가 나는데 빨간줄이 끄이지 않음 : 컨셉이 없어서
	//ranges::sort(lst.end(), lst.begin());	// 컨셉이 있어서 빨간줄 나면서 실행조차 안됨

	save("소스.cpp");
}

//----------------------------------------------------------<새로운 저장>-------------------------------------------------------
파일 이름 : 소스.cpp
파일크기:1816
2022-05-26 15:17:56 GMT+9

//---------------------------------<금일 강의 목표>----------------------------
// 2022년 1학기 STL	5.26	수910목56 (13주 1일)
// 
// C++20의 핵심
// concepts
// range/view
//		coroutine
//		module - 확장자 ixx, : 아직 쓰기는 멀었다.
// 
// Metaprogramming library : 컴파일 단계에 물어볼 수 있다.
// type traits - Metaprogramming의 도구, is_ 시리즈, 
// 
// 6/15(수) (15주 1일) - 기말시험
// 6/16(목) (15주 2일) - 강의 끝
// 
//-----------------------------------------------------------------------------

#include <iostream>
#include <vector>
#include <list>
#include <deque>
#include <algorithm>
#include <concepts>	// concepts : 만족해야 하는 조건, 예) https://en.cppreference.com/w/cpp/iterator/random_access_iterator
#include <ranges> //range는 컨셉이 붙은 함수들이다. (기존 함수는 이전 버전과 호환을 위해 컨셉을 넣지 않았다.)

#include "save.h"
#include "STRING.h"

using namespace std;

template<input_iterator Iter>
long long dist(Iter b, Iter e) 
{
	// 만일 random_access 반복자라면 -로 계산
	if constexpr (is_same_v<typename iterator_traits<Iter>::iterator_category, random_access_iterator_tag>) {
		cout << " -로 계산 " << endl;
		return e - b;
	}

	// 아니라면 
	// (이 코드만 남으면 좋은데 list 반복자가 전달될때 위의 e-b 코드도 생성된다.)
	// --> list 반복자가 - 연산을 지원하지 않기 때문에 compile 오류
	// C++17이전 - tag dispatching으로 해결한다.
	// C++17이후 - constexpr if (선택적 코드생성)로 해결가능
	else {
		long long step = 0;
		while (b != e) {
			++step;
			++b;
		}
		cout << "한 걸음씩 세서 계산" << endl;
		return step;
	}

}

//---------------------------
int main()
//---------------------------
{
	vector<int> v{ 1,3,5,7,9,2,4,6,8,10 };

	ranges::sort(v);

	for (int n : v)
		cout << n << " ";

	save("소스.cpp");
}

//----------------------------------------------------------<새로운 저장>-------------------------------------------------------
파일 이름 : 소스.cpp
파일크기:1992
2022-06-02 13:56:57 GMT+9

//---------------------------------<금일 강의 목표>----------------------------
// 2022년 1학기 STL	6.2	수910목56 (13주 2일) - 6월1일은 선거라 휴강했음
// 
// C++20의 핵심
// concepts
// range/view
//		coroutine
//		module - 확장자 ixx, : 아직 쓰기는 멀었다.
// 
// Metaprogramming library : 컴파일 단계에 물어볼 수 있다.
// type traits - Metaprogramming의 도구, is_ 시리즈, 
// 
// 6/15(수) (15주 1일) - 기말시험
// 6/16(목) (15주 2일) - 강의 끝
// 
//-----------------------------------------------------------------------------

#include <iostream>
#include <vector>
#include <list>
#include <deque>
#include <forward_list>
#include <iterator>

#include <algorithm>
#include <concepts>	// concepts : 만족해야 하는 조건, 예) https://en.cppreference.com/w/cpp/iterator/random_access_iterator
#include <ranges> //range는 컨셉이 붙은 함수들이다. (기존 함수는 이전 버전과 호환을 위해 컨셉을 넣지 않았다.)

#include "save.h"
#include "STRING.h"

using namespace std;

template<input_or_output_iterator Iter>
void f(Iter iter) 
{
	if (contiguous_iterator<Iter>)
		cout << "contiguous 반복자" << endl;
	if (random_access_iterator<Iter>)
		cout << "random-access 반복자" << endl;
	if (bidirectional_iterator<Iter>)
		cout << "bidirectional 반복자" << endl;
	if (forward_iterator<Iter>)
		cout << "forward 반복자" << endl;
	if (input_iterator<Iter>)
		cout << "input 반복자" << endl;
	//if (output_iterator<Iter>)
	//	cout << "output반복자" << endl;

	cout << endl;
	cout << "---------------------------------------------" << endl;
	cout << endl;
}

//---------------------------
int main()
//---------------------------
{
	//[문제] 함수 f는 반복자를 인자로 받는다.
	// f는 반복자 category를 출력한다.

	f(vector<char>::iterator{});
	f(deque<double>::const_reverse_iterator{});
	f(list<int>{}.begin());
	f(forward_list<int>::iterator{});
	f(istream_iterator<int>{cin});

	//f(3.4); // 제약조건 통과안됨

	

	save("소스.cpp");
}

//----------------------------------------------------------<새로운 저장>-------------------------------------------------------
파일 이름 : 소스.cpp
파일크기:1005
2022-06-02 14:17:06 GMT+9

//---------------------------------<금일 강의 목표>----------------------------
// 2022년 1학기 STL	6.2	수910목56 (13주 2일) - 6월1일은 선거라 휴강했음
// 
// C++20의 핵심
// concepts
// range/view
//		coroutine
//		module - 확장자 ixx, : 아직 쓰기는 멀었다.
// 
// Metaprogramming library : 컴파일 단계에 물어볼 수 있다.
// type traits - Metaprogramming의 도구, is_ 시리즈, 
// 
// 6/15(수) (15주 1일) - 기말시험
// 6/16(목) (15주 2일) - 강의 끝
// 
//-----------------------------------------------------------------------------

#include <iostream>
#include <algorithm>
#include <ranges>
#include "save.h"
#include "STRING.h"

using namespace std;


//---------------------------
int main()
//---------------------------
{
	int a[]{ 1,3,5,7,9,2,4,6,8,10 };

	//sort(begin(a), end(a));
	auto v = views::all(a);	// view를 통해 벡터처럼 사용할 수 있게 되었다.
	sort(v.begin(), v.end());
	

	for (int n : a)
		cout << n << " ";
	cout << endl;

	save("소스.cpp");
}

//----------------------------------------------------------<새로운 저장>-------------------------------------------------------
파일 이름 : 소스.cpp
파일크기:1054
2022-06-02 14:23:12 GMT+9

//---------------------------------<금일 강의 목표>----------------------------
// 2022년 1학기 STL	6.2	수910목56 (13주 2일) - 6월1일은 선거라 휴강했음
// 
// C++20의 핵심
// concepts
// range/view
//		coroutine
//		module - 확장자 ixx, : 아직 쓰기는 멀었다.
// 
// Metaprogramming library : 컴파일 단계에 물어볼 수 있다.
// type traits - Metaprogramming의 도구, is_ 시리즈, 
// 
// 6/15(수) (15주 1일) - 기말시험
// 6/16(목) (15주 2일) - 강의 끝
// 
//-----------------------------------------------------------------------------

#include <iostream>
#include <algorithm>
#include <ranges>
#include <list>
#include "save.h"
#include "STRING.h"

using namespace std;


//---------------------------
int main()
//---------------------------
{
	int a[]{ 1,3,5,7,9,2,4,6,8,10 };
	//list<int> a{ 1,3,5,7,9,2,4,6,8,10 };

	//sort(begin(a), end(a));
	auto v = views::all(a);
	ranges::sort(v);	// list는 랜덤엑서스가 아니기 때문에 빨간줄이 끄인다.
	

	for (int n : a)
		cout << n << " ";
	cout << endl;

	save("소스.cpp");
}

//----------------------------------------------------------<새로운 저장>-------------------------------------------------------
파일 이름 : 소스.cpp
파일크기:1535
2022-06-02 14:38:30 GMT+9

//---------------------------------<금일 강의 목표>----------------------------
// 2022년 1학기 STL	6.2	수910목56 (13주 2일) - 6월1일은 선거라 휴강했음
// 
// C++20의 핵심
// concepts
// range/view
//		coroutine
//		module - 확장자 ixx, : 아직 쓰기는 멀었다.
// 
// Metaprogramming library : 컴파일 단계에 물어볼 수 있다.
// type traits - Metaprogramming의 도구, is_ 시리즈, 
// 
// 6/15(수) (15주 1일) - 기말시험
// 6/16(목) (15주 2일) - 강의 끝
// 
//-----------------------------------------------------------------------------

#include <iostream>
#include <algorithm>
#include <ranges>
#include <string>
#include <random>
#include "save.h"
#include "STRING.h"

using namespace std;

default_random_engine dre;
uniform_int_distribution uidNum{ 1,100 };
uniform_int_distribution<int> uidName{ 'a', 'z'};

class Dog {
	string name;
	int num;

public:
	Dog() {
		for (int i = 0; i < 5; ++i)
			name += uidName(dre);
		num = uidNum(dre);
	}

	string getName() const {
		return name;
	}

	int getNum() const {
		return num;
	}

};

//---------------------------
int main()
//---------------------------
{
	vector<Dog> v(100);

	// [문제] 숫자 기준 오름차순 정렬
	ranges::sort(v, {}, &Dog::getNum);	// ranges::sort(v, 기준, projection), projection = 기준으로 취급하여 정렬(함수)해도 되겠니?
	// int는 잘 알려진 자료형이기 때문에 {}로 써도된다. 원래는 = less<int>()

	for (const Dog& dog : v)
		cout << dog.getName() << " - " << dog.getNum() << endl;

	save("소스.cpp");
}

//----------------------------------------------------------<새로운 저장>-------------------------------------------------------
파일 이름 : 소스.cpp
파일크기:1520
2022-06-02 14:58:09 GMT+9

//---------------------------------<금일 강의 목표>----------------------------
// 2022년 1학기 STL	6.2	수910목56 (13주 2일) - 6월1일은 선거라 휴강했음
// 
// C++20의 핵심
// concepts
// range/view
//		coroutine
//		module - 확장자 ixx, : 아직 쓰기는 멀었다.
// 
// Metaprogramming library : 컴파일 단계에 물어볼 수 있다.
// type traits - Metaprogramming의 도구, is_ 시리즈, 
// 
// 6/15(수) (15주 1일) - 기말시험
// 6/16(목) (15주 2일) - 강의 끝
// 
//-----------------------------------------------------------------------------

#include <iostream>
#include <algorithm>
#include <ranges>
#include <string>
#include <random>
#include "save.h"
#include "STRING.h"

using namespace std;

default_random_engine dre;
uniform_int_distribution uidNum{ 1,100 };
uniform_int_distribution<int> uidName{ 'a', 'z'};

class Dog {
	string name;
	int num;

public:
	Dog() {
		for (int i = 0; i < 5; ++i)
			name += uidName(dre);
		num = uidNum(dre);
	}

	string getName() const {
		return name;
	}

	int getNum() const {
		return num;
	}

};

//---------------------------
int main()
//---------------------------
{
	vector<Dog> v(100);

	// [문제] 숫자 기준 내림차순 정렬하고 앞에서 부터 10개만 출력하라
	ranges::sort(v, less<int>(), &Dog::getNum);	// ranges::sort(v, 기준, projection), projection = 기준으로 취급하여 정렬(함수)해도 되겠니?

	for (const Dog& dog : v | views::take(10) )
		cout << dog.getName() << " - " << dog.getNum() << endl;

	save("소스.cpp");
}

//----------------------------------------------------------<새로운 저장>-------------------------------------------------------
파일 이름 : 소스.cpp
파일크기:1375
2022-06-02 15:12:15 GMT+9

//---------------------------------<금일 강의 목표>----------------------------
// 2022년 1학기 STL	6.2	수910목56 (13주 2일) - 6월1일은 선거라 휴강했음
// 
// C++20의 핵심
// concepts
// range/view
//		coroutine
//		module - 확장자 ixx, : 아직 쓰기는 멀었다.
// 
// Metaprogramming library : 컴파일 단계에 물어볼 수 있다.
// type traits - Metaprogramming의 도구, is_ 시리즈, 
// 
// 6/15(수) (15주 1일) - 기말시험
// 6/16(목) (15주 2일) - 강의 끝
// 
//-----------------------------------------------------------------------------

#include <iostream>
#include <ranges>
#include "save.h"
#include "STRING.h"

using namespace std;

//---------------------------
int main()
//---------------------------
{
	int a[]{ 1,3,5,7,9,2,4,6,8,10 };

	auto v = views::all(a);		// v 는 a를 처다보는 가벼운 객체이다.
	*v.begin() = 333;	// view가 래퍼런스 view이기 때문에 실제 값을 바꿀수 있다.

	cout << sizeof(v) << endl;
	cout << typeid(v).name() << endl;

	// [문제] v에서 홀수만 골라 제곱하라.
	auto 홀수 = [](int n) {return n % 2; };
	auto 제곱 = [](int n) {return n * n; };

	for (int n : v | views::filter(홀수) 
				   | views::transform(제곱) )	// 범위(range)기반 for 루프, v대신 {1,2,3,4,5,6,7,8,9} 와 같이 사용도 가능
		cout << n << " ";
	cout << endl;

	for (int& n : v)
		cout << n << " ";
	cout << endl;

	save("소스.cpp");
}

//----------------------------------------------------------<새로운 저장>-------------------------------------------------------
파일 이름 : 소스.cpp
파일크기:1155
2022-06-02 15:20:43 GMT+9

//---------------------------------<금일 강의 목표>----------------------------
// 2022년 1학기 STL	6.2	수910목56 (13주 2일) - 6월1일은 선거라 휴강했음
// 
// C++20의 핵심
// concepts
// range/view
//		coroutine
//		module - 확장자 ixx, : 아직 쓰기는 멀었다.
// 
// Metaprogramming library : 컴파일 단계에 물어볼 수 있다.
// type traits - Metaprogramming의 도구, is_ 시리즈, 
// 
// 6/15(수) (15주 1일) - 기말시험
// 6/16(목) (15주 2일) - 강의 끝
// 
//-----------------------------------------------------------------------------

#include <iostream>
#include <ranges>
#include <format>
#include "save.h"
#include "STRING.h"

using namespace std;

//---------------------------
int main()
//---------------------------
{
	// 10000부터 시작하는 무한개의 자연수를 생성하고 홀수 2000개를 역순으로 출력하라.
	auto odd = [](int n) {return n % 2; };
	for (int n : views::iota(10000) | views::filter(odd)	// 주어진 순서대로 수행된다.
									| views::take(2000) 
									| views::reverse )	// 따라서 reverse가 앞에오면 무한대의 자연수를 reverse할 수 없기 때문에 오류난다.
		cout << format("{:8}", n);

	save("소스.cpp");
}

//----------------------------------------------------------<새로운 저장>-------------------------------------------------------
파일 이름 : 소스.cpp
파일크기:1549
2022-06-08 18:09:02 GMT+9

//---------------------------------<금일 강의 목표>----------------------------
// 2022년 1학기 STL	6.8	수910목56 (14주 1일)
// 
// C++20의 핵심
// concepts
// range/view
//		coroutine
//		module - 확장자 ixx, : 아직 쓰기는 멀었다.
// 
// Metaprogramming library : 컴파일 단계에 물어볼 수 있다.
// type traits - Metaprogramming의 도구, is_ 시리즈, 
// 
// constrained = 컨셉(제약사항)으로 재작성한 함수 
//					=> 제약으로 더 빠르게(컴파일 시간에) 오류를 검출할 수 있다.
//					=> range를 통해 
// 
// span - array, vector, T[*], string : contiguous한 자료들을 통일시키기 위해
// range - iterable한 자료들을 알고리즘과 엮어서 만든 것
// 
// 6/15(수) (15주 1일) - 기말시험
// 6/16(목) (15주 2일) - 강의 끝
// 
//-----------------------------------------------------------------------------

#include <iostream>
#include <ranges>
#include <format>
#include "save.h"
#include "STRING.h"

using namespace std;

bool 소수(int num) 
{
	for (int i = 2; i * i <= num; ++i)
		if (num % i == 0)
			return false; //num이 i의 배수면 소수가 아니므로 false
	return true;
}

//---------------------------
int main()
//---------------------------
{
	// [문제] 10000부터 정수 중 소수(prime number)를 100개만 출력하라
	//2 3 5 7 11 13 17 19 23
	// rnage? [b, e)  [s, num)  [s, pred())  [s....)

	for (int n : views::iota(1) | views::drop(100)
									| views::filter(소수) 
									| views::take(100)
									| views::reverse
									| views::take(10)
		)
		cout << format("{:8}", n);

	save("소스.cpp");
}

//----------------------------------------------------------<새로운 저장>-------------------------------------------------------
파일 이름 : 소스.cpp
파일크기:2001
2022-06-08 18:32:22 GMT+9

//---------------------------------<금일 강의 목표>----------------------------
// 2022년 1학기 STL	6.8	수910목56 (14주 1일)
// 
// C++20의 핵심
// concepts
// range/view
//		coroutine
//		module - 확장자 ixx, : 아직 쓰기는 멀었다.
// 
// Metaprogramming library : 컴파일 단계에 물어볼 수 있다.
// type traits - Metaprogramming의 도구, is_ 시리즈, 
// 
// constrained = 컨셉(제약사항)으로 재작성한 함수 
//					=> 제약으로 더 빠르게(컴파일 시간에) 오류를 검출할 수 있다.
//					=> range를 통해 
// 
// span - array, vector, T[*], string : contiguous한 자료들을 통일시키기 위해
// range - iterable한 자료들을 알고리즘과 엮어서 만든 것
// 
// 6/15(수) (15주 1일) - 기말시험
// 6/16(목) (15주 2일) - 강의 끝
// 
//-----------------------------------------------------------------------------

#include <iostream>
#include <fstream>
#include <string>
#include <vector>
#include <ranges>
#include <set>
#include "save.h"
#include "STRING.h"

using namespace std;

//---------------------------
int main()
//---------------------------
{
	// [문제] "단어들.txt"에 몇 단어가 있나 출력하라.
	ifstream in("단어들.txt");

	//방법1)
	//cout << "단어의 개수 - " << distance(istream_iterator<string>{in}, {});

	//방법2)
	//int n = 0;
	//string s;
	//while (in >> s)
	//	++n;
	//cout << "단어의 개수 - " << n;

	//방법3)
	vector<string> v{ istream_iterator<string>{in}, {} };
	cout << "단어의 개수 - " << v.size() << endl;			//369882

	// [문제] 단어들.txt는 정렬되어 있나?
	cout << "정렬? : " << boolalpha << ranges::is_sorted(v, less<string>{}) << endl; // is_sorted(v.begin(), v.end());

	// [문제] 중복된 단어가 있나?
	
	// 방법1)
	//unique는 정렬되어 있을때만 쓸수 있으며, 중복된 데이터가 없다면 end()를 리턴할 것이다.
	auto p = unique(v.begin(), v.end());
	if (p == v.end())
		cout << "중복 없음" << endl;

	// 방법2)
	set<string> s{ v.begin(), v.end() };
	if (s.size() == v.size())
		cout << "중복 없음" << endl;

	save("소스.cpp");
}

//----------------------------------------------------------<새로운 저장>-------------------------------------------------------
파일 이름 : 소스.cpp
파일크기:3357
2022-06-09 15:16:25 GMT+9

//---------------------------------<금일 강의 목표>----------------------------
// 2022년 1학기 STL	6.8	수910목56 (14주 1일)
// 
// 14주 강의 - 애너그램
// 
// 6/15(수) (15주 1일) - 기말시험
// 6/16(목) (15주 2일) - 강의 끝
// 
//-----------------------------------------------------------------------------

#include <iostream>
#include <fstream>
#include <ranges>
#include <algorithm>
#include <fstream>

#include <string>
#include <vector>
#include <list>

#include "save.h"
#include "STRING.h"

using namespace std;

struct WP : public pair<string, string> {
	WP(const string& s) : pair<string, string>{ s,s } {
		ranges::sort(first);
	}
};

//---------------------------
int main()
//---------------------------
{
	// [문제] "단어들.txt"에 몇 단어가 있나 출력하라.
	ifstream in("단어들.txt");
	vector<WP> v{ istream_iterator<string>{in}, {} };
	cout << "단어의 개수 - " << v.size() << endl;			//369882

	// [문제] first 기준으로 정렬하라.
	ranges::sort(v, {}, &WP::first);

	//sort(v.begin(), v.end(), [](const WP& a, const WP& b) {
	//	return a.first < b.first;
	//	});


	// [문제] 일부분을 화면에 출력하라.
	//for (const auto& [정렬, 원본] : v	| views::drop(10000)
	//									| views::take(100)
	//	)
	//	cout << 정렬 << " --- " << 원본 << endl;

	// [문제] 전체 anagram 쌍을 화면에 출력하라.
	auto b = v.cbegin();
	int cnt{};

	// [문제] 가장 개수가 많은 애너그램은 몇개?
	// [문제] 애너그램 갯수 순으로 출력하라.
	vector<list<string>> vs;
	vs.reserve(31000);


	while (true) {
		auto i = adjacent_find(b, v.cend(), [](const WP& a, const WP& b) {
			return a.first == b.first;
			});
		if (i == v.end())
			break;

		auto j = find_if_not(i + 1, v.cend(), [i](const WP& a) {
			return a.first == i->first;
			});

		//[i,j)는 애너그램 구간이다.
		list<string> ls;
		for (auto p = i; p < j; ++p)
			ls.push_back(p->second);
		vs.push_back(ls);

		b = j;
	}

	// vs를 개수 내림파순으로 정렬
	sort(vs.begin(), vs.end(), [](const list<string>& a, const list<string>& b) {
		return a.size() > b.size();
		});

	cout << "가장 많은 애너그램 - " << vs.begin()->size() << endl;

	for (const list<string>& ls : vs	| views::drop(10)
										| views::take(10)
		) {
		for (const string& s : ls)
			cout << s << "  ";
		cout << endl;
	}
		

	//while (true) {
	//	string word;
	//	cout << "단어를 입력하시오 : ";
	//	cin >> word;
	//	// [문제] word가 사전에 있으면 anagram을 출력, 없으면 없는 단어라고 출력
	//	// 방법1)
	//	auto [하한, 상한] = equal_range(v.begin(), v.end(), WP(word), [](const WP& a, const WP& b) {
	//		return a.first < b.first;
	//		});

	//	if (하한 == 상한)
	//		cout << word << " - 사전에 없다" << endl;
	//	else if (상한 - 하한 == 1)
	//		cout << word << "의 anagram은 없다" << endl;
	//	else {
	//		cout << word << " - ";
	//		for (auto b = 하한; b < 상한; ++b)
	//			cout << b->second << "  ";
	//		cout << endl;
	//	}


	//	// 방법2)
	//	//string sortedWord{ word };
	//	//ranges::sort(sortedWord);
	//	//auto [b, e] = ranges::equal_range(v, sortedWord, {}, &WP::first);

	//	//auto p = ranges::find(b, e, word, &WP::second);
	//	//if (p == e)
	//	//	cout << word << "는 사전에 없습니다." << endl;
	//	//else
	//	//	cout << word << "는 사전에 있습니다." << endl;

	//}




	save("소스.cpp");
}

//----------------------------------------------------------<새로운 저장>-------------------------------------------------------
파일 이름 : 소스.cpp
파일크기:4581
2022-06-16 13:50:58 GMT+9

//---------------------------------<금일 강의 목표>----------------------------
// 2022년 1학기 STL	6.15	수910목56 (기말고사)
// 
// 기말고사 - 시험
//-----------------------------------------------------------------------------

#include <iostream>
#include <fstream>
#include <format>
#include <vector>
#include <string>
#include <map>
#include <unordered_map>
#include <set>
#include <unordered_set>
#include <random>
#include <ranges>
#include <algorithm>
#include <numeric>

#include "save.h"

using namespace std;

//class REV : public vector<string>::iterator {
//public:
//    REV(vector<string>::iterator it) : vector<string>::iterator(it) {
//
//    }
//    REV& operator++() {	//자기 자신이 변하기 때문에 const를 쓰면 안됨
//        reverse((*this)->begin(), (*this)->end());
//        (*this)++;
//        return *this;
//    }
//
//};

class REV {
public: 
    vector<string>::iterator it;
public:
    REV(vector<string>::iterator iter) {
        it = iter;
    }
    REV& operator++() {	//자기 자신이 변하기 때문에 const를 쓰면 안됨
        reverse(it->begin(), it->end());
        it++;
        return *this;
    }
    string& operator*() {	//자기 자신이 변하기 때문에 const를 쓰면 안됨
        return *it;
    }

};

//---------------------------
int main()
//---------------------------
{
    ifstream in{ "이상한 나라의 앨리스.txt" };

    vector<string> v;

    // [문제 1] 파일 "이상한 나라의 앨리스.txt"에 있는 모든 단어를 읽어 컨테이너 v에 저장하라.
    // 모두 몇 개의 단어를 읽었는지 화면에 출력하고 출력결과를 답지에도 적어라.   (15, 5)                             
    // (주의) v는 이미 생성되어있다.
    v.reserve(10000);
    string input1;
    while (in >> input1)
        v.push_back(input1);
    cout << "단어의 개수 - " << v.size() << endl;

    // [문제 2]  v에서 "rabbit" 이라는 단어는 모두 몇 개인가? 
    // 몇 개인지 화면에 출력하고 답지에 출력된 개수도 적어라.                    (20, 5)
    // (주의) rabbit은 대소문자를 구분하지 않는다 
    // (예) rabbit Rabbit RABBIT Rabbit-Hole - 여기에서 rabbit은 3개이다.
    int rabbitNum = count_if(v.begin(), v.end(), [](const string& s) {
        string temp{s};
        ranges::transform(s, temp.begin(), [](char c) { return tolower(c); });
        return temp == "rabbit";
        });
    cout << "rabbit의 수 - " << rabbitNum << endl;

    // 다음과 같이 v를 단어사전으로 만들었다.

    sort(v.begin(), v.end());
    v.erase(unique(v.begin(), v.end()), v.end());
    cout << "사전으로 만든 v의 단어 수 - " << v.size() << endl;
    // (출력) 사전으로 만든 v의 단어 수 - 5295


    // [문제 3] 사전을 단어의 길이 기준 오름차순으로 정렬하라.
    // 사전의 첫 단어와 마지막 단어를 화면에 출력하고 답안지에도 적어라. 	(15, 5)				
    // (주의) 길이가 같은 단어들 끼리는 오름차순으로 정렬되어야 한다.
    // (참고) 다음은 문제를 해결한 후 2001번째 부터 10개 단어를 출력한 것이다.
    // '--you 'After 'Begin 'Boots 'Bring 'Can't 'Come, 'DRINK 'Dear, 'Don't
    ranges::sort(v, [](const string& a, const string& b) {
        if (a.size() == b.size())
            return a < b;
        return a.size() < b.size();
        });
    cout << "첫단어-" << *v.cbegin() << endl << "두번째 단어-" << *v.crbegin() << endl;

    // "단어들.txt"를 words에 저장한다.
    ifstream in2{ "단어들.txt" };
    vector<string> words{ istream_iterator<string>{in2}, {} };
    cout << "단어들.txt - " << words.size() << endl;
    // (출력) 단어들.txt - 369882

    vector<string> v2;              // v의 단어가 "단어들.txt"에 있는 단어라면 여기에 저장한다.

    // [문제 4] v에 있는 단어 중에서 "단어들.txt"에 있는 단어를 찾아 v2에 저장하라.              
    // v2에 모두 몇 단어가 있는지 출력하고 답지에도 써라.  (20, 5)
    ranges::sort(words);
    for (const string& s : v)
        if (ranges::binary_search(words, s))
            v2.push_back(s);
    cout << "v2단어의 개수 - " << v2.size() << endl;

    // [문제 5] 다음과 표준 알고리즘함수 copy를 호출하면 v2의 모든 단어가 역순으로 바뀐다.
    // 필요한 코딩을 추가하라.                                                (40)
    // (예) v2의 단어가 다음과 같다고 하자.    Alice was beginning to 
    // copy 호출 후에는 다음과 같이 바뀐다.    ecilA saw gninnigeb ot

    for (const string& s : v2 | views::take(20))
        cout << s << " ";
    cout << endl;

    copy(v2.begin(), v2.end(), REV(v2.begin()));

    for (const string& s : v2 | views::take(20))
        cout << s << " ";
    cout << endl;

    save("소스.cpp");
    
}

//----------------------------------------------------------<새로운 저장>-------------------------------------------------------
파일 이름 : 소스.cpp
파일크기:2149
2022-06-16 14:59:25 GMT+9

//---------------------------------<금일 강의 목표>----------------------------
// 2022년 1학기 STL	6.15	수910목56 (최종정리)
// Generic Programming의 개념을 설명할 수 있다.   : 자료형에 무관하게 코딩할 수 있는 기법
// c++에서 템플릿을 이용하여 클래스와 함수를 만들 수 있다.
// 이렇게 만든 클래스와 함수는 무슨 자료형이 넘겨지더라도 문제가 없다.
// 
// C++의 특징 : 밑바닥까지 손댈 수 있다.(포인터)
// 
// range for 는 begin와 end가 정의 되어 있어야한다.
// move, &, && = l-value 래퍼런스, r-value 래퍼런스, 이동연사자
// 
// r-value 래퍼런스 : move문법을 완성하기 위해나옴, 
// const : 값을 바꾸지 않는 다는 것을 명시하는 역할
// lambda : 함수호출을 오버로딩한 이름없는 클래스
// concept : 템플릿에 제약을 주기위한것
// range : 컨셉을 이용하여 함수를 다시 정의한것
// view : 
// 
// 스마트 포인터 : 포인터를 한번더 감싸서 메모리 해제를 알아서 해주는 객체
// 
// 호출가능 타입 : operator()() ,  lambda, 함수포인터
// 
// STRING을 만들어 가며 STL의 장동원리를 이해 하였다 : 
//      생성자, 소멸자, 복사생성, 복사 할당, 이동생성, 이동할당
//      begin, end를 제공하는 반복자를 만들어봄 (iterator의 조건이 있다, 특질:어떤 특성들을 가지고 있나.)
// 
// 컨테이너의 종류 : sequence 컨테이너, associative 컨테이너, Unordered associative 컨테이너
// 반복자의 종류 : cotiguous, random_access, bidrection, forward, input, output
// 알고리즘 작동방식을 설명할 수 있다 : begin, end로 접근하여 원소를 수정하지 않는 알고리즘, 원소를 수정하는 알고리즘, 정렬하는 알고리즘이 있다.
// 
// 직접 작성한 for loop 보다 알고리즘 함수를 사용하는 것이 좋다는 것을 안다.
// C++20의 concept으로 재작성된 constrained 알고리즘 함수가 있다. : 타입에 따라 적절한 함수를 컴파일 타임에 선택할 수 있어 에러를 줄일 수 있다.
// C++20의 range/view concept를 사용하면 함수를 쉽게 조합하고 projection을 통해 좀더 편하게 코딩가능
// 
// &와 const를 잘 이해하고 쓰면 어디 가서도 기본은 할 수 있다.
// 
// C++ core guidelines 참고
// modoocode.com 참고
//
//-----------------------------------------------------------------------------

#include <iostream>
#include "save.h"

using namespace std;

//---------------------------
int main()
//---------------------------
{
    save("소스.cpp");
}